schema {
  query: query_root
  subscription: subscription_root
}

# columns and relationships of "ban"
type ban {
  detectedAt: timestamp!
  id: Int!

  # An object relationship
  player: player
  playerId: Int
  preExisting: Boolean!
  type: ban_type_enum!
  unbanned: Boolean!
  unbannedAt: timestamp
}

# aggregated selection of "ban"
type ban_aggregate {
  aggregate: ban_aggregate_fields
  nodes: [ban!]!
}

# aggregate fields of "ban"
type ban_aggregate_fields {
  avg: ban_avg_fields
  count(columns: [ban_select_column!], distinct: Boolean): Int
  max: ban_max_fields
  min: ban_min_fields
  stddev: ban_stddev_fields
  stddev_pop: ban_stddev_pop_fields
  stddev_samp: ban_stddev_samp_fields
  sum: ban_sum_fields
  var_pop: ban_var_pop_fields
  var_samp: ban_var_samp_fields
  variance: ban_variance_fields
}

# order by aggregate values of table "ban"
input ban_aggregate_order_by {
  avg: ban_avg_order_by
  count: order_by
  max: ban_max_order_by
  min: ban_min_order_by
  stddev: ban_stddev_order_by
  stddev_pop: ban_stddev_pop_order_by
  stddev_samp: ban_stddev_samp_order_by
  sum: ban_sum_order_by
  var_pop: ban_var_pop_order_by
  var_samp: ban_var_samp_order_by
  variance: ban_variance_order_by
}

# aggregate avg on columns
type ban_avg_fields {
  id: Float
  playerId: Float
}

# order by avg() on columns of table "ban"
input ban_avg_order_by {
  id: order_by
  playerId: order_by
}

# Boolean expression to filter rows from the table "ban". All fields are combined with a logical 'AND'.
input ban_bool_exp {
  _and: [ban_bool_exp]
  _not: ban_bool_exp
  _or: [ban_bool_exp]
  detectedAt: timestamp_comparison_exp
  id: Int_comparison_exp
  player: player_bool_exp
  playerId: Int_comparison_exp
  preExisting: Boolean_comparison_exp
  type: ban_type_enum_comparison_exp
  unbanned: Boolean_comparison_exp
  unbannedAt: timestamp_comparison_exp
}

# aggregate max on columns
type ban_max_fields {
  id: Int
  playerId: Int
}

# order by max() on columns of table "ban"
input ban_max_order_by {
  id: order_by
  playerId: order_by
}

# aggregate min on columns
type ban_min_fields {
  id: Int
  playerId: Int
}

# order by min() on columns of table "ban"
input ban_min_order_by {
  id: order_by
  playerId: order_by
}

# ordering options when selecting data from "ban"
input ban_order_by {
  detectedAt: order_by
  id: order_by
  player: player_order_by
  playerId: order_by
  preExisting: order_by
  type: order_by
  unbanned: order_by
  unbannedAt: order_by
}

# select columns of table "ban"
enum ban_select_column {
  # column name
  detectedAt

  # column name
  id

  # column name
  playerId

  # column name
  preExisting

  # column name
  type

  # column name
  unbanned

  # column name
  unbannedAt
}

# aggregate stddev on columns
type ban_stddev_fields {
  id: Float
  playerId: Float
}

# order by stddev() on columns of table "ban"
input ban_stddev_order_by {
  id: order_by
  playerId: order_by
}

# aggregate stddev_pop on columns
type ban_stddev_pop_fields {
  id: Float
  playerId: Float
}

# order by stddev_pop() on columns of table "ban"
input ban_stddev_pop_order_by {
  id: order_by
  playerId: order_by
}

# aggregate stddev_samp on columns
type ban_stddev_samp_fields {
  id: Float
  playerId: Float
}

# order by stddev_samp() on columns of table "ban"
input ban_stddev_samp_order_by {
  id: order_by
  playerId: order_by
}

# aggregate sum on columns
type ban_sum_fields {
  id: Int
  playerId: Int
}

# order by sum() on columns of table "ban"
input ban_sum_order_by {
  id: order_by
  playerId: order_by
}

scalar ban_type_enum

# expression to compare columns of type ban_type_enum. All fields are combined with logical 'AND'.
input ban_type_enum_comparison_exp {
  _eq: ban_type_enum
  _gt: ban_type_enum
  _gte: ban_type_enum
  _in: [ban_type_enum!]
  _is_null: Boolean
  _lt: ban_type_enum
  _lte: ban_type_enum
  _neq: ban_type_enum
  _nin: [ban_type_enum!]
}

# aggregate var_pop on columns
type ban_var_pop_fields {
  id: Float
  playerId: Float
}

# order by var_pop() on columns of table "ban"
input ban_var_pop_order_by {
  id: order_by
  playerId: order_by
}

# aggregate var_samp on columns
type ban_var_samp_fields {
  id: Float
  playerId: Float
}

# order by var_samp() on columns of table "ban"
input ban_var_samp_order_by {
  id: order_by
  playerId: order_by
}

# aggregate variance on columns
type ban_variance_fields {
  id: Float
  playerId: Float
}

# order by variance() on columns of table "ban"
input ban_variance_order_by {
  id: order_by
  playerId: order_by
}

# columns and relationships of "bomb_status"
type bomb_status {
  createdAt: timestamp!
  id: Int!
  playerId: Int

  # An object relationship
  player_info: player_info

  # An object relationship
  position: position
  positionId: Int

  # An object relationship
  round: round
  roundId: Int
  tick: Int!
  type: bomb_status_type_enum!
}

# aggregated selection of "bomb_status"
type bomb_status_aggregate {
  aggregate: bomb_status_aggregate_fields
  nodes: [bomb_status!]!
}

# aggregate fields of "bomb_status"
type bomb_status_aggregate_fields {
  avg: bomb_status_avg_fields
  count(columns: [bomb_status_select_column!], distinct: Boolean): Int
  max: bomb_status_max_fields
  min: bomb_status_min_fields
  stddev: bomb_status_stddev_fields
  stddev_pop: bomb_status_stddev_pop_fields
  stddev_samp: bomb_status_stddev_samp_fields
  sum: bomb_status_sum_fields
  var_pop: bomb_status_var_pop_fields
  var_samp: bomb_status_var_samp_fields
  variance: bomb_status_variance_fields
}

# order by aggregate values of table "bomb_status"
input bomb_status_aggregate_order_by {
  avg: bomb_status_avg_order_by
  count: order_by
  max: bomb_status_max_order_by
  min: bomb_status_min_order_by
  stddev: bomb_status_stddev_order_by
  stddev_pop: bomb_status_stddev_pop_order_by
  stddev_samp: bomb_status_stddev_samp_order_by
  sum: bomb_status_sum_order_by
  var_pop: bomb_status_var_pop_order_by
  var_samp: bomb_status_var_samp_order_by
  variance: bomb_status_variance_order_by
}

# aggregate avg on columns
type bomb_status_avg_fields {
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by avg() on columns of table "bomb_status"
input bomb_status_avg_order_by {
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# Boolean expression to filter rows from the table "bomb_status". All fields are combined with a logical 'AND'.
input bomb_status_bool_exp {
  _and: [bomb_status_bool_exp]
  _not: bomb_status_bool_exp
  _or: [bomb_status_bool_exp]
  createdAt: timestamp_comparison_exp
  id: Int_comparison_exp
  playerId: Int_comparison_exp
  player_info: player_info_bool_exp
  position: position_bool_exp
  positionId: Int_comparison_exp
  round: round_bool_exp
  roundId: Int_comparison_exp
  tick: Int_comparison_exp
  type: bomb_status_type_enum_comparison_exp
}

# aggregate max on columns
type bomb_status_max_fields {
  id: Int
  playerId: Int
  positionId: Int
  roundId: Int
  tick: Int
}

# order by max() on columns of table "bomb_status"
input bomb_status_max_order_by {
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate min on columns
type bomb_status_min_fields {
  id: Int
  playerId: Int
  positionId: Int
  roundId: Int
  tick: Int
}

# order by min() on columns of table "bomb_status"
input bomb_status_min_order_by {
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# ordering options when selecting data from "bomb_status"
input bomb_status_order_by {
  createdAt: order_by
  id: order_by
  playerId: order_by
  player_info: player_info_order_by
  position: position_order_by
  positionId: order_by
  round: round_order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# select columns of table "bomb_status"
enum bomb_status_select_column {
  # column name
  createdAt

  # column name
  id

  # column name
  playerId

  # column name
  positionId

  # column name
  roundId

  # column name
  tick

  # column name
  type
}

# aggregate stddev on columns
type bomb_status_stddev_fields {
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by stddev() on columns of table "bomb_status"
input bomb_status_stddev_order_by {
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate stddev_pop on columns
type bomb_status_stddev_pop_fields {
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by stddev_pop() on columns of table "bomb_status"
input bomb_status_stddev_pop_order_by {
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate stddev_samp on columns
type bomb_status_stddev_samp_fields {
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by stddev_samp() on columns of table "bomb_status"
input bomb_status_stddev_samp_order_by {
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate sum on columns
type bomb_status_sum_fields {
  id: Int
  playerId: Int
  positionId: Int
  roundId: Int
  tick: Int
}

# order by sum() on columns of table "bomb_status"
input bomb_status_sum_order_by {
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

scalar bomb_status_type_enum

# expression to compare columns of type bomb_status_type_enum. All fields are combined with logical 'AND'.
input bomb_status_type_enum_comparison_exp {
  _eq: bomb_status_type_enum
  _gt: bomb_status_type_enum
  _gte: bomb_status_type_enum
  _in: [bomb_status_type_enum!]
  _is_null: Boolean
  _lt: bomb_status_type_enum
  _lte: bomb_status_type_enum
  _neq: bomb_status_type_enum
  _nin: [bomb_status_type_enum!]
}

# aggregate var_pop on columns
type bomb_status_var_pop_fields {
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by var_pop() on columns of table "bomb_status"
input bomb_status_var_pop_order_by {
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate var_samp on columns
type bomb_status_var_samp_fields {
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by var_samp() on columns of table "bomb_status"
input bomb_status_var_samp_order_by {
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate variance on columns
type bomb_status_variance_fields {
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by variance() on columns of table "bomb_status"
input bomb_status_variance_order_by {
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

scalar date

# expression to compare columns of type date. All fields are combined with logical 'AND'.
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# columns and relationships of "kill"
type kill {
  # An object relationship
  assister: player_info
  assisterId: Int

  # An object relationship
  attacker: player_info
  attackerId: Int
  createdAt: timestamp!
  id: Int!

  # An object relationship
  round: round
  roundId: Int
  throughSmoke: Boolean!
  throughWall: Boolean!
  tick: Int!

  # An object relationship
  victim: player_info
  victimId: Int
  whileBlind: Boolean!
}

# aggregated selection of "kill"
type kill_aggregate {
  aggregate: kill_aggregate_fields
  nodes: [kill!]!
}

# aggregate fields of "kill"
type kill_aggregate_fields {
  avg: kill_avg_fields
  count(columns: [kill_select_column!], distinct: Boolean): Int
  max: kill_max_fields
  min: kill_min_fields
  stddev: kill_stddev_fields
  stddev_pop: kill_stddev_pop_fields
  stddev_samp: kill_stddev_samp_fields
  sum: kill_sum_fields
  var_pop: kill_var_pop_fields
  var_samp: kill_var_samp_fields
  variance: kill_variance_fields
}

# order by aggregate values of table "kill"
input kill_aggregate_order_by {
  avg: kill_avg_order_by
  count: order_by
  max: kill_max_order_by
  min: kill_min_order_by
  stddev: kill_stddev_order_by
  stddev_pop: kill_stddev_pop_order_by
  stddev_samp: kill_stddev_samp_order_by
  sum: kill_sum_order_by
  var_pop: kill_var_pop_order_by
  var_samp: kill_var_samp_order_by
  variance: kill_variance_order_by
}

# aggregate avg on columns
type kill_avg_fields {
  assisterId: Float
  attackerId: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by avg() on columns of table "kill"
input kill_avg_order_by {
  assisterId: order_by
  attackerId: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# Boolean expression to filter rows from the table "kill". All fields are combined with a logical 'AND'.
input kill_bool_exp {
  _and: [kill_bool_exp]
  _not: kill_bool_exp
  _or: [kill_bool_exp]
  assister: player_info_bool_exp
  assisterId: Int_comparison_exp
  attacker: player_info_bool_exp
  attackerId: Int_comparison_exp
  createdAt: timestamp_comparison_exp
  id: Int_comparison_exp
  round: round_bool_exp
  roundId: Int_comparison_exp
  throughSmoke: Boolean_comparison_exp
  throughWall: Boolean_comparison_exp
  tick: Int_comparison_exp
  victim: player_info_bool_exp
  victimId: Int_comparison_exp
  whileBlind: Boolean_comparison_exp
}

# aggregate max on columns
type kill_max_fields {
  assisterId: Int
  attackerId: Int
  id: Int
  roundId: Int
  tick: Int
  victimId: Int
}

# order by max() on columns of table "kill"
input kill_max_order_by {
  assisterId: order_by
  attackerId: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate min on columns
type kill_min_fields {
  assisterId: Int
  attackerId: Int
  id: Int
  roundId: Int
  tick: Int
  victimId: Int
}

# order by min() on columns of table "kill"
input kill_min_order_by {
  assisterId: order_by
  attackerId: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# ordering options when selecting data from "kill"
input kill_order_by {
  assister: player_info_order_by
  assisterId: order_by
  attacker: player_info_order_by
  attackerId: order_by
  createdAt: order_by
  id: order_by
  round: round_order_by
  roundId: order_by
  throughSmoke: order_by
  throughWall: order_by
  tick: order_by
  victim: player_info_order_by
  victimId: order_by
  whileBlind: order_by
}

# select columns of table "kill"
enum kill_select_column {
  # column name
  assisterId

  # column name
  attackerId

  # column name
  createdAt

  # column name
  id

  # column name
  roundId

  # column name
  throughSmoke

  # column name
  throughWall

  # column name
  tick

  # column name
  victimId

  # column name
  whileBlind
}

# aggregate stddev on columns
type kill_stddev_fields {
  assisterId: Float
  attackerId: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by stddev() on columns of table "kill"
input kill_stddev_order_by {
  assisterId: order_by
  attackerId: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate stddev_pop on columns
type kill_stddev_pop_fields {
  assisterId: Float
  attackerId: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by stddev_pop() on columns of table "kill"
input kill_stddev_pop_order_by {
  assisterId: order_by
  attackerId: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate stddev_samp on columns
type kill_stddev_samp_fields {
  assisterId: Float
  attackerId: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by stddev_samp() on columns of table "kill"
input kill_stddev_samp_order_by {
  assisterId: order_by
  attackerId: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate sum on columns
type kill_sum_fields {
  assisterId: Int
  attackerId: Int
  id: Int
  roundId: Int
  tick: Int
  victimId: Int
}

# order by sum() on columns of table "kill"
input kill_sum_order_by {
  assisterId: order_by
  attackerId: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate var_pop on columns
type kill_var_pop_fields {
  assisterId: Float
  attackerId: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by var_pop() on columns of table "kill"
input kill_var_pop_order_by {
  assisterId: order_by
  attackerId: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate var_samp on columns
type kill_var_samp_fields {
  assisterId: Float
  attackerId: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by var_samp() on columns of table "kill"
input kill_var_samp_order_by {
  assisterId: order_by
  attackerId: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate variance on columns
type kill_variance_fields {
  assisterId: Float
  attackerId: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by variance() on columns of table "kill"
input kill_variance_order_by {
  assisterId: order_by
  attackerId: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# columns and relationships of "match"
type match {
  date: timestamp!
  durationTicks: Int
  externalId: String!
  id: Int!
  map: String

  # An array relationship
  players(
    # distinct select on columns
    distinct_on: [match_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_players_player_order_by!]

    # filter the rows returned
    where: match_players_player_bool_exp
  ): [match_players_player!]!

  # An aggregated array relationship
  players_aggregate(
    # distinct select on columns
    distinct_on: [match_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_players_player_order_by!]

    # filter the rows returned
    where: match_players_player_bool_exp
  ): match_players_player_aggregate!

  # An array relationship
  rounds(
    # distinct select on columns
    distinct_on: [round_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [round_order_by!]

    # filter the rows returned
    where: round_bool_exp
  ): [round!]!

  # An aggregated array relationship
  rounds_aggregate(
    # distinct select on columns
    distinct_on: [round_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [round_order_by!]

    # filter the rows returned
    where: round_bool_exp
  ): round_aggregate!

  # An array relationship
  team_matches_matches(
    # distinct select on columns
    distinct_on: [team_matches_match_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_matches_match_order_by!]

    # filter the rows returned
    where: team_matches_match_bool_exp
  ): [team_matches_match!]!

  # An aggregated array relationship
  team_matches_matches_aggregate(
    # distinct select on columns
    distinct_on: [team_matches_match_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_matches_match_order_by!]

    # filter the rows returned
    where: team_matches_match_bool_exp
  ): team_matches_match_aggregate!
  tickrate: Int
  type: Int
  typeExtended: String
}

# aggregated selection of "match"
type match_aggregate {
  aggregate: match_aggregate_fields
  nodes: [match!]!
}

# aggregate fields of "match"
type match_aggregate_fields {
  avg: match_avg_fields
  count(columns: [match_select_column!], distinct: Boolean): Int
  max: match_max_fields
  min: match_min_fields
  stddev: match_stddev_fields
  stddev_pop: match_stddev_pop_fields
  stddev_samp: match_stddev_samp_fields
  sum: match_sum_fields
  var_pop: match_var_pop_fields
  var_samp: match_var_samp_fields
  variance: match_variance_fields
}

# order by aggregate values of table "match"
input match_aggregate_order_by {
  avg: match_avg_order_by
  count: order_by
  max: match_max_order_by
  min: match_min_order_by
  stddev: match_stddev_order_by
  stddev_pop: match_stddev_pop_order_by
  stddev_samp: match_stddev_samp_order_by
  sum: match_sum_order_by
  var_pop: match_var_pop_order_by
  var_samp: match_var_samp_order_by
  variance: match_variance_order_by
}

# aggregate avg on columns
type match_avg_fields {
  durationTicks: Float
  id: Float
  tickrate: Float
  type: Float
}

# order by avg() on columns of table "match"
input match_avg_order_by {
  durationTicks: order_by
  id: order_by
  tickrate: order_by
  type: order_by
}

# Boolean expression to filter rows from the table "match". All fields are combined with a logical 'AND'.
input match_bool_exp {
  _and: [match_bool_exp]
  _not: match_bool_exp
  _or: [match_bool_exp]
  date: timestamp_comparison_exp
  durationTicks: Int_comparison_exp
  externalId: String_comparison_exp
  id: Int_comparison_exp
  map: String_comparison_exp
  players: match_players_player_bool_exp
  rounds: round_bool_exp
  team_matches_matches: team_matches_match_bool_exp
  tickrate: Int_comparison_exp
  type: Int_comparison_exp
  typeExtended: String_comparison_exp
}

# aggregate max on columns
type match_max_fields {
  durationTicks: Int
  externalId: String
  id: Int
  map: String
  tickrate: Int
  type: Int
  typeExtended: String
}

# order by max() on columns of table "match"
input match_max_order_by {
  durationTicks: order_by
  externalId: order_by
  id: order_by
  map: order_by
  tickrate: order_by
  type: order_by
  typeExtended: order_by
}

# aggregate min on columns
type match_min_fields {
  durationTicks: Int
  externalId: String
  id: Int
  map: String
  tickrate: Int
  type: Int
  typeExtended: String
}

# order by min() on columns of table "match"
input match_min_order_by {
  durationTicks: order_by
  externalId: order_by
  id: order_by
  map: order_by
  tickrate: order_by
  type: order_by
  typeExtended: order_by
}

# ordering options when selecting data from "match"
input match_order_by {
  date: order_by
  durationTicks: order_by
  externalId: order_by
  id: order_by
  map: order_by
  players_aggregate: match_players_player_aggregate_order_by
  rounds_aggregate: round_aggregate_order_by
  team_matches_matches_aggregate: team_matches_match_aggregate_order_by
  tickrate: order_by
  type: order_by
  typeExtended: order_by
}

# columns and relationships of "match_players_player"
type match_players_player {
  # An object relationship
  match: match!
  matchId: Int!

  # An object relationship
  player: player!
  playerId: Int!
}

# aggregated selection of "match_players_player"
type match_players_player_aggregate {
  aggregate: match_players_player_aggregate_fields
  nodes: [match_players_player!]!
}

# aggregate fields of "match_players_player"
type match_players_player_aggregate_fields {
  avg: match_players_player_avg_fields
  count(columns: [match_players_player_select_column!], distinct: Boolean): Int
  max: match_players_player_max_fields
  min: match_players_player_min_fields
  stddev: match_players_player_stddev_fields
  stddev_pop: match_players_player_stddev_pop_fields
  stddev_samp: match_players_player_stddev_samp_fields
  sum: match_players_player_sum_fields
  var_pop: match_players_player_var_pop_fields
  var_samp: match_players_player_var_samp_fields
  variance: match_players_player_variance_fields
}

# order by aggregate values of table "match_players_player"
input match_players_player_aggregate_order_by {
  avg: match_players_player_avg_order_by
  count: order_by
  max: match_players_player_max_order_by
  min: match_players_player_min_order_by
  stddev: match_players_player_stddev_order_by
  stddev_pop: match_players_player_stddev_pop_order_by
  stddev_samp: match_players_player_stddev_samp_order_by
  sum: match_players_player_sum_order_by
  var_pop: match_players_player_var_pop_order_by
  var_samp: match_players_player_var_samp_order_by
  variance: match_players_player_variance_order_by
}

# aggregate avg on columns
type match_players_player_avg_fields {
  matchId: Float
  playerId: Float
}

# order by avg() on columns of table "match_players_player"
input match_players_player_avg_order_by {
  matchId: order_by
  playerId: order_by
}

# Boolean expression to filter rows from the table "match_players_player". All fields are combined with a logical 'AND'.
input match_players_player_bool_exp {
  _and: [match_players_player_bool_exp]
  _not: match_players_player_bool_exp
  _or: [match_players_player_bool_exp]
  match: match_bool_exp
  matchId: Int_comparison_exp
  player: player_bool_exp
  playerId: Int_comparison_exp
}

# aggregate max on columns
type match_players_player_max_fields {
  matchId: Int
  playerId: Int
}

# order by max() on columns of table "match_players_player"
input match_players_player_max_order_by {
  matchId: order_by
  playerId: order_by
}

# aggregate min on columns
type match_players_player_min_fields {
  matchId: Int
  playerId: Int
}

# order by min() on columns of table "match_players_player"
input match_players_player_min_order_by {
  matchId: order_by
  playerId: order_by
}

# ordering options when selecting data from "match_players_player"
input match_players_player_order_by {
  match: match_order_by
  matchId: order_by
  player: player_order_by
  playerId: order_by
}

# select columns of table "match_players_player"
enum match_players_player_select_column {
  # column name
  matchId

  # column name
  playerId
}

# aggregate stddev on columns
type match_players_player_stddev_fields {
  matchId: Float
  playerId: Float
}

# order by stddev() on columns of table "match_players_player"
input match_players_player_stddev_order_by {
  matchId: order_by
  playerId: order_by
}

# aggregate stddev_pop on columns
type match_players_player_stddev_pop_fields {
  matchId: Float
  playerId: Float
}

# order by stddev_pop() on columns of table "match_players_player"
input match_players_player_stddev_pop_order_by {
  matchId: order_by
  playerId: order_by
}

# aggregate stddev_samp on columns
type match_players_player_stddev_samp_fields {
  matchId: Float
  playerId: Float
}

# order by stddev_samp() on columns of table "match_players_player"
input match_players_player_stddev_samp_order_by {
  matchId: order_by
  playerId: order_by
}

# aggregate sum on columns
type match_players_player_sum_fields {
  matchId: Int
  playerId: Int
}

# order by sum() on columns of table "match_players_player"
input match_players_player_sum_order_by {
  matchId: order_by
  playerId: order_by
}

# aggregate var_pop on columns
type match_players_player_var_pop_fields {
  matchId: Float
  playerId: Float
}

# order by var_pop() on columns of table "match_players_player"
input match_players_player_var_pop_order_by {
  matchId: order_by
  playerId: order_by
}

# aggregate var_samp on columns
type match_players_player_var_samp_fields {
  matchId: Float
  playerId: Float
}

# order by var_samp() on columns of table "match_players_player"
input match_players_player_var_samp_order_by {
  matchId: order_by
  playerId: order_by
}

# aggregate variance on columns
type match_players_player_variance_fields {
  matchId: Float
  playerId: Float
}

# order by variance() on columns of table "match_players_player"
input match_players_player_variance_order_by {
  matchId: order_by
  playerId: order_by
}

# select columns of table "match"
enum match_select_column {
  # column name
  date

  # column name
  durationTicks

  # column name
  externalId

  # column name
  id

  # column name
  map

  # column name
  tickrate

  # column name
  type

  # column name
  typeExtended
}

# aggregate stddev on columns
type match_stddev_fields {
  durationTicks: Float
  id: Float
  tickrate: Float
  type: Float
}

# order by stddev() on columns of table "match"
input match_stddev_order_by {
  durationTicks: order_by
  id: order_by
  tickrate: order_by
  type: order_by
}

# aggregate stddev_pop on columns
type match_stddev_pop_fields {
  durationTicks: Float
  id: Float
  tickrate: Float
  type: Float
}

# order by stddev_pop() on columns of table "match"
input match_stddev_pop_order_by {
  durationTicks: order_by
  id: order_by
  tickrate: order_by
  type: order_by
}

# aggregate stddev_samp on columns
type match_stddev_samp_fields {
  durationTicks: Float
  id: Float
  tickrate: Float
  type: Float
}

# order by stddev_samp() on columns of table "match"
input match_stddev_samp_order_by {
  durationTicks: order_by
  id: order_by
  tickrate: order_by
  type: order_by
}

# aggregate sum on columns
type match_sum_fields {
  durationTicks: Int
  id: Int
  tickrate: Int
  type: Int
}

# order by sum() on columns of table "match"
input match_sum_order_by {
  durationTicks: order_by
  id: order_by
  tickrate: order_by
  type: order_by
}

# columns and relationships of "match_teams_team"
type match_teams_team {
  # An object relationship
  match: match!
  matchId: Int!

  # An object relationship
  team: team!
  teamId: Int!
}

# aggregated selection of "match_teams_team"
type match_teams_team_aggregate {
  aggregate: match_teams_team_aggregate_fields
  nodes: [match_teams_team!]!
}

# aggregate fields of "match_teams_team"
type match_teams_team_aggregate_fields {
  avg: match_teams_team_avg_fields
  count(columns: [match_teams_team_select_column!], distinct: Boolean): Int
  max: match_teams_team_max_fields
  min: match_teams_team_min_fields
  stddev: match_teams_team_stddev_fields
  stddev_pop: match_teams_team_stddev_pop_fields
  stddev_samp: match_teams_team_stddev_samp_fields
  sum: match_teams_team_sum_fields
  var_pop: match_teams_team_var_pop_fields
  var_samp: match_teams_team_var_samp_fields
  variance: match_teams_team_variance_fields
}

# order by aggregate values of table "match_teams_team"
input match_teams_team_aggregate_order_by {
  avg: match_teams_team_avg_order_by
  count: order_by
  max: match_teams_team_max_order_by
  min: match_teams_team_min_order_by
  stddev: match_teams_team_stddev_order_by
  stddev_pop: match_teams_team_stddev_pop_order_by
  stddev_samp: match_teams_team_stddev_samp_order_by
  sum: match_teams_team_sum_order_by
  var_pop: match_teams_team_var_pop_order_by
  var_samp: match_teams_team_var_samp_order_by
  variance: match_teams_team_variance_order_by
}

# aggregate avg on columns
type match_teams_team_avg_fields {
  matchId: Float
  teamId: Float
}

# order by avg() on columns of table "match_teams_team"
input match_teams_team_avg_order_by {
  matchId: order_by
  teamId: order_by
}

# Boolean expression to filter rows from the table "match_teams_team". All fields are combined with a logical 'AND'.
input match_teams_team_bool_exp {
  _and: [match_teams_team_bool_exp]
  _not: match_teams_team_bool_exp
  _or: [match_teams_team_bool_exp]
  match: match_bool_exp
  matchId: Int_comparison_exp
  team: team_bool_exp
  teamId: Int_comparison_exp
}

# aggregate max on columns
type match_teams_team_max_fields {
  matchId: Int
  teamId: Int
}

# order by max() on columns of table "match_teams_team"
input match_teams_team_max_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate min on columns
type match_teams_team_min_fields {
  matchId: Int
  teamId: Int
}

# order by min() on columns of table "match_teams_team"
input match_teams_team_min_order_by {
  matchId: order_by
  teamId: order_by
}

# ordering options when selecting data from "match_teams_team"
input match_teams_team_order_by {
  match: match_order_by
  matchId: order_by
  team: team_order_by
  teamId: order_by
}

# select columns of table "match_teams_team"
enum match_teams_team_select_column {
  # column name
  matchId

  # column name
  teamId
}

# aggregate stddev on columns
type match_teams_team_stddev_fields {
  matchId: Float
  teamId: Float
}

# order by stddev() on columns of table "match_teams_team"
input match_teams_team_stddev_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate stddev_pop on columns
type match_teams_team_stddev_pop_fields {
  matchId: Float
  teamId: Float
}

# order by stddev_pop() on columns of table "match_teams_team"
input match_teams_team_stddev_pop_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate stddev_samp on columns
type match_teams_team_stddev_samp_fields {
  matchId: Float
  teamId: Float
}

# order by stddev_samp() on columns of table "match_teams_team"
input match_teams_team_stddev_samp_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate sum on columns
type match_teams_team_sum_fields {
  matchId: Int
  teamId: Int
}

# order by sum() on columns of table "match_teams_team"
input match_teams_team_sum_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate var_pop on columns
type match_teams_team_var_pop_fields {
  matchId: Float
  teamId: Float
}

# order by var_pop() on columns of table "match_teams_team"
input match_teams_team_var_pop_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate var_samp on columns
type match_teams_team_var_samp_fields {
  matchId: Float
  teamId: Float
}

# order by var_samp() on columns of table "match_teams_team"
input match_teams_team_var_samp_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate variance on columns
type match_teams_team_variance_fields {
  matchId: Float
  teamId: Float
}

# order by variance() on columns of table "match_teams_team"
input match_teams_team_variance_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate var_pop on columns
type match_var_pop_fields {
  durationTicks: Float
  id: Float
  tickrate: Float
  type: Float
}

# order by var_pop() on columns of table "match"
input match_var_pop_order_by {
  durationTicks: order_by
  id: order_by
  tickrate: order_by
  type: order_by
}

# aggregate var_samp on columns
type match_var_samp_fields {
  durationTicks: Float
  id: Float
  tickrate: Float
  type: Float
}

# order by var_samp() on columns of table "match"
input match_var_samp_order_by {
  durationTicks: order_by
  id: order_by
  tickrate: order_by
  type: order_by
}

# aggregate variance on columns
type match_variance_fields {
  durationTicks: Float
  id: Float
  tickrate: Float
  type: Float
}

# order by variance() on columns of table "match"
input match_variance_order_by {
  durationTicks: order_by
  id: order_by
  tickrate: order_by
  type: order_by
}

# columns and relationships of "notification"
type notification {
  # An object relationship
  ban: ban
  banId: Int
  createdAt: date!
  deleted: Boolean!
  id: Int!
  seen: Boolean!

  # An object relationship
  user: user
  userId: Int
}

# aggregated selection of "notification"
type notification_aggregate {
  aggregate: notification_aggregate_fields
  nodes: [notification!]!
}

# aggregate fields of "notification"
type notification_aggregate_fields {
  avg: notification_avg_fields
  count(columns: [notification_select_column!], distinct: Boolean): Int
  max: notification_max_fields
  min: notification_min_fields
  stddev: notification_stddev_fields
  stddev_pop: notification_stddev_pop_fields
  stddev_samp: notification_stddev_samp_fields
  sum: notification_sum_fields
  var_pop: notification_var_pop_fields
  var_samp: notification_var_samp_fields
  variance: notification_variance_fields
}

# order by aggregate values of table "notification"
input notification_aggregate_order_by {
  avg: notification_avg_order_by
  count: order_by
  max: notification_max_order_by
  min: notification_min_order_by
  stddev: notification_stddev_order_by
  stddev_pop: notification_stddev_pop_order_by
  stddev_samp: notification_stddev_samp_order_by
  sum: notification_sum_order_by
  var_pop: notification_var_pop_order_by
  var_samp: notification_var_samp_order_by
  variance: notification_variance_order_by
}

# aggregate avg on columns
type notification_avg_fields {
  banId: Float
  id: Float
  userId: Float
}

# order by avg() on columns of table "notification"
input notification_avg_order_by {
  banId: order_by
  id: order_by
  userId: order_by
}

# columns and relationships of "notification_bans_ban"
type notification_bans_ban {
  # An object relationship
  ban: ban!
  banId: Int!

  # An object relationship
  notification: notification!
  notificationId: Int!
}

# aggregated selection of "notification_bans_ban"
type notification_bans_ban_aggregate {
  aggregate: notification_bans_ban_aggregate_fields
  nodes: [notification_bans_ban!]!
}

# aggregate fields of "notification_bans_ban"
type notification_bans_ban_aggregate_fields {
  avg: notification_bans_ban_avg_fields
  count(columns: [notification_bans_ban_select_column!], distinct: Boolean): Int
  max: notification_bans_ban_max_fields
  min: notification_bans_ban_min_fields
  stddev: notification_bans_ban_stddev_fields
  stddev_pop: notification_bans_ban_stddev_pop_fields
  stddev_samp: notification_bans_ban_stddev_samp_fields
  sum: notification_bans_ban_sum_fields
  var_pop: notification_bans_ban_var_pop_fields
  var_samp: notification_bans_ban_var_samp_fields
  variance: notification_bans_ban_variance_fields
}

# order by aggregate values of table "notification_bans_ban"
input notification_bans_ban_aggregate_order_by {
  avg: notification_bans_ban_avg_order_by
  count: order_by
  max: notification_bans_ban_max_order_by
  min: notification_bans_ban_min_order_by
  stddev: notification_bans_ban_stddev_order_by
  stddev_pop: notification_bans_ban_stddev_pop_order_by
  stddev_samp: notification_bans_ban_stddev_samp_order_by
  sum: notification_bans_ban_sum_order_by
  var_pop: notification_bans_ban_var_pop_order_by
  var_samp: notification_bans_ban_var_samp_order_by
  variance: notification_bans_ban_variance_order_by
}

# aggregate avg on columns
type notification_bans_ban_avg_fields {
  banId: Float
  notificationId: Float
}

# order by avg() on columns of table "notification_bans_ban"
input notification_bans_ban_avg_order_by {
  banId: order_by
  notificationId: order_by
}

# Boolean expression to filter rows from the table "notification_bans_ban". All fields are combined with a logical 'AND'.
input notification_bans_ban_bool_exp {
  _and: [notification_bans_ban_bool_exp]
  _not: notification_bans_ban_bool_exp
  _or: [notification_bans_ban_bool_exp]
  ban: ban_bool_exp
  banId: Int_comparison_exp
  notification: notification_bool_exp
  notificationId: Int_comparison_exp
}

# aggregate max on columns
type notification_bans_ban_max_fields {
  banId: Int
  notificationId: Int
}

# order by max() on columns of table "notification_bans_ban"
input notification_bans_ban_max_order_by {
  banId: order_by
  notificationId: order_by
}

# aggregate min on columns
type notification_bans_ban_min_fields {
  banId: Int
  notificationId: Int
}

# order by min() on columns of table "notification_bans_ban"
input notification_bans_ban_min_order_by {
  banId: order_by
  notificationId: order_by
}

# ordering options when selecting data from "notification_bans_ban"
input notification_bans_ban_order_by {
  ban: ban_order_by
  banId: order_by
  notification: notification_order_by
  notificationId: order_by
}

# select columns of table "notification_bans_ban"
enum notification_bans_ban_select_column {
  # column name
  banId

  # column name
  notificationId
}

# aggregate stddev on columns
type notification_bans_ban_stddev_fields {
  banId: Float
  notificationId: Float
}

# order by stddev() on columns of table "notification_bans_ban"
input notification_bans_ban_stddev_order_by {
  banId: order_by
  notificationId: order_by
}

# aggregate stddev_pop on columns
type notification_bans_ban_stddev_pop_fields {
  banId: Float
  notificationId: Float
}

# order by stddev_pop() on columns of table "notification_bans_ban"
input notification_bans_ban_stddev_pop_order_by {
  banId: order_by
  notificationId: order_by
}

# aggregate stddev_samp on columns
type notification_bans_ban_stddev_samp_fields {
  banId: Float
  notificationId: Float
}

# order by stddev_samp() on columns of table "notification_bans_ban"
input notification_bans_ban_stddev_samp_order_by {
  banId: order_by
  notificationId: order_by
}

# aggregate sum on columns
type notification_bans_ban_sum_fields {
  banId: Int
  notificationId: Int
}

# order by sum() on columns of table "notification_bans_ban"
input notification_bans_ban_sum_order_by {
  banId: order_by
  notificationId: order_by
}

# aggregate var_pop on columns
type notification_bans_ban_var_pop_fields {
  banId: Float
  notificationId: Float
}

# order by var_pop() on columns of table "notification_bans_ban"
input notification_bans_ban_var_pop_order_by {
  banId: order_by
  notificationId: order_by
}

# aggregate var_samp on columns
type notification_bans_ban_var_samp_fields {
  banId: Float
  notificationId: Float
}

# order by var_samp() on columns of table "notification_bans_ban"
input notification_bans_ban_var_samp_order_by {
  banId: order_by
  notificationId: order_by
}

# aggregate variance on columns
type notification_bans_ban_variance_fields {
  banId: Float
  notificationId: Float
}

# order by variance() on columns of table "notification_bans_ban"
input notification_bans_ban_variance_order_by {
  banId: order_by
  notificationId: order_by
}

# Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
input notification_bool_exp {
  _and: [notification_bool_exp]
  _not: notification_bool_exp
  _or: [notification_bool_exp]
  ban: ban_bool_exp
  banId: Int_comparison_exp
  createdAt: date_comparison_exp
  deleted: Boolean_comparison_exp
  id: Int_comparison_exp
  seen: Boolean_comparison_exp
  user: user_bool_exp
  userId: Int_comparison_exp
}

# aggregate max on columns
type notification_max_fields {
  banId: Int
  createdAt: date
  id: Int
  userId: Int
}

# order by max() on columns of table "notification"
input notification_max_order_by {
  banId: order_by
  createdAt: order_by
  id: order_by
  userId: order_by
}

# aggregate min on columns
type notification_min_fields {
  banId: Int
  createdAt: date
  id: Int
  userId: Int
}

# order by min() on columns of table "notification"
input notification_min_order_by {
  banId: order_by
  createdAt: order_by
  id: order_by
  userId: order_by
}

# ordering options when selecting data from "notification"
input notification_order_by {
  ban: ban_order_by
  banId: order_by
  createdAt: order_by
  deleted: order_by
  id: order_by
  seen: order_by
  user: user_order_by
  userId: order_by
}

# select columns of table "notification"
enum notification_select_column {
  # column name
  banId

  # column name
  createdAt

  # column name
  deleted

  # column name
  id

  # column name
  seen

  # column name
  userId
}

# aggregate stddev on columns
type notification_stddev_fields {
  banId: Float
  id: Float
  userId: Float
}

# order by stddev() on columns of table "notification"
input notification_stddev_order_by {
  banId: order_by
  id: order_by
  userId: order_by
}

# aggregate stddev_pop on columns
type notification_stddev_pop_fields {
  banId: Float
  id: Float
  userId: Float
}

# order by stddev_pop() on columns of table "notification"
input notification_stddev_pop_order_by {
  banId: order_by
  id: order_by
  userId: order_by
}

# aggregate stddev_samp on columns
type notification_stddev_samp_fields {
  banId: Float
  id: Float
  userId: Float
}

# order by stddev_samp() on columns of table "notification"
input notification_stddev_samp_order_by {
  banId: order_by
  id: order_by
  userId: order_by
}

# aggregate sum on columns
type notification_sum_fields {
  banId: Int
  id: Int
  userId: Int
}

# order by sum() on columns of table "notification"
input notification_sum_order_by {
  banId: order_by
  id: order_by
  userId: order_by
}

# aggregate var_pop on columns
type notification_var_pop_fields {
  banId: Float
  id: Float
  userId: Float
}

# order by var_pop() on columns of table "notification"
input notification_var_pop_order_by {
  banId: order_by
  id: order_by
  userId: order_by
}

# aggregate var_samp on columns
type notification_var_samp_fields {
  banId: Float
  id: Float
  userId: Float
}

# order by var_samp() on columns of table "notification"
input notification_var_samp_order_by {
  banId: order_by
  id: order_by
  userId: order_by
}

# aggregate variance on columns
type notification_variance_fields {
  banId: Float
  id: Float
  userId: Float
}

# order by variance() on columns of table "notification"
input notification_variance_order_by {
  banId: order_by
  id: order_by
  userId: order_by
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# columns and relationships of "player"
type player {
  # An array relationship
  bans(
    # distinct select on columns
    distinct_on: [ban_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [ban_order_by!]

    # filter the rows returned
    where: ban_bool_exp
  ): [ban!]!

  # An aggregated array relationship
  bans_aggregate(
    # distinct select on columns
    distinct_on: [ban_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [ban_order_by!]

    # filter the rows returned
    where: ban_bool_exp
  ): ban_aggregate!
  createdAt: timestamp!

  # An array relationship
  followedBy(
    # distinct select on columns
    distinct_on: [player_followed_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_followed_by_user_order_by!]

    # filter the rows returned
    where: player_followed_by_user_bool_exp
  ): [player_followed_by_user!]!

  # An aggregated array relationship
  followedBy_aggregate(
    # distinct select on columns
    distinct_on: [player_followed_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_followed_by_user_order_by!]

    # filter the rows returned
    where: player_followed_by_user_bool_exp
  ): player_followed_by_user_aggregate!
  id: Int!
  lastCheckedAt: timestamp!

  # An array relationship
  matches(
    # distinct select on columns
    distinct_on: [match_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_players_player_order_by!]

    # filter the rows returned
    where: match_players_player_bool_exp
  ): [match_players_player!]!

  # An aggregated array relationship
  matches_aggregate(
    # distinct select on columns
    distinct_on: [match_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_players_player_order_by!]

    # filter the rows returned
    where: match_players_player_bool_exp
  ): match_players_player_aggregate!

  # An array relationship
  player_infos(
    # distinct select on columns
    distinct_on: [player_info_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_info_order_by!]

    # filter the rows returned
    where: player_info_bool_exp
  ): [player_info!]!

  # An aggregated array relationship
  player_infos_aggregate(
    # distinct select on columns
    distinct_on: [player_info_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_info_order_by!]

    # filter the rows returned
    where: player_info_bool_exp
  ): player_info_aggregate!
  steamAvatar: String
  steamId: String!
  steamProfile: String
  steamUsername: String

  # An array relationship
  teams(
    # distinct select on columns
    distinct_on: [team_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_players_player_order_by!]

    # filter the rows returned
    where: team_players_player_bool_exp
  ): [team_players_player!]!

  # An aggregated array relationship
  teams_aggregate(
    # distinct select on columns
    distinct_on: [team_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_players_player_order_by!]

    # filter the rows returned
    where: team_players_player_bool_exp
  ): team_players_player_aggregate!

  # An array relationship
  trackedBy(
    # distinct select on columns
    distinct_on: [player_tracked_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_tracked_by_user_order_by!]

    # filter the rows returned
    where: player_tracked_by_user_bool_exp
  ): [player_tracked_by_user!]!

  # An aggregated array relationship
  trackedBy_aggregate(
    # distinct select on columns
    distinct_on: [player_tracked_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_tracked_by_user_order_by!]

    # filter the rows returned
    where: player_tracked_by_user_bool_exp
  ): player_tracked_by_user_aggregate!
}

# aggregated selection of "player"
type player_aggregate {
  aggregate: player_aggregate_fields
  nodes: [player!]!
}

# aggregate fields of "player"
type player_aggregate_fields {
  avg: player_avg_fields
  count(columns: [player_select_column!], distinct: Boolean): Int
  max: player_max_fields
  min: player_min_fields
  stddev: player_stddev_fields
  stddev_pop: player_stddev_pop_fields
  stddev_samp: player_stddev_samp_fields
  sum: player_sum_fields
  var_pop: player_var_pop_fields
  var_samp: player_var_samp_fields
  variance: player_variance_fields
}

# order by aggregate values of table "player"
input player_aggregate_order_by {
  avg: player_avg_order_by
  count: order_by
  max: player_max_order_by
  min: player_min_order_by
  stddev: player_stddev_order_by
  stddev_pop: player_stddev_pop_order_by
  stddev_samp: player_stddev_samp_order_by
  sum: player_sum_order_by
  var_pop: player_var_pop_order_by
  var_samp: player_var_samp_order_by
  variance: player_variance_order_by
}

# aggregate avg on columns
type player_avg_fields {
  id: Float
}

# order by avg() on columns of table "player"
input player_avg_order_by {
  id: order_by
}

# columns and relationships of "player_blind"
type player_blind {
  # An object relationship
  attacker: player_info
  attackerId: Int
  createdAt: timestamp!
  duration: Int!
  id: Int!

  # An object relationship
  round: round
  roundId: Int
  tick: Int!

  # An object relationship
  victim: player_info
  victimId: Int
}

# aggregated selection of "player_blind"
type player_blind_aggregate {
  aggregate: player_blind_aggregate_fields
  nodes: [player_blind!]!
}

# aggregate fields of "player_blind"
type player_blind_aggregate_fields {
  avg: player_blind_avg_fields
  count(columns: [player_blind_select_column!], distinct: Boolean): Int
  max: player_blind_max_fields
  min: player_blind_min_fields
  stddev: player_blind_stddev_fields
  stddev_pop: player_blind_stddev_pop_fields
  stddev_samp: player_blind_stddev_samp_fields
  sum: player_blind_sum_fields
  var_pop: player_blind_var_pop_fields
  var_samp: player_blind_var_samp_fields
  variance: player_blind_variance_fields
}

# order by aggregate values of table "player_blind"
input player_blind_aggregate_order_by {
  avg: player_blind_avg_order_by
  count: order_by
  max: player_blind_max_order_by
  min: player_blind_min_order_by
  stddev: player_blind_stddev_order_by
  stddev_pop: player_blind_stddev_pop_order_by
  stddev_samp: player_blind_stddev_samp_order_by
  sum: player_blind_sum_order_by
  var_pop: player_blind_var_pop_order_by
  var_samp: player_blind_var_samp_order_by
  variance: player_blind_variance_order_by
}

# aggregate avg on columns
type player_blind_avg_fields {
  attackerId: Float
  duration: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by avg() on columns of table "player_blind"
input player_blind_avg_order_by {
  attackerId: order_by
  duration: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# Boolean expression to filter rows from the table "player_blind". All fields are combined with a logical 'AND'.
input player_blind_bool_exp {
  _and: [player_blind_bool_exp]
  _not: player_blind_bool_exp
  _or: [player_blind_bool_exp]
  attacker: player_info_bool_exp
  attackerId: Int_comparison_exp
  createdAt: timestamp_comparison_exp
  duration: Int_comparison_exp
  id: Int_comparison_exp
  round: round_bool_exp
  roundId: Int_comparison_exp
  tick: Int_comparison_exp
  victim: player_info_bool_exp
  victimId: Int_comparison_exp
}

# aggregate max on columns
type player_blind_max_fields {
  attackerId: Int
  duration: Int
  id: Int
  roundId: Int
  tick: Int
  victimId: Int
}

# order by max() on columns of table "player_blind"
input player_blind_max_order_by {
  attackerId: order_by
  duration: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate min on columns
type player_blind_min_fields {
  attackerId: Int
  duration: Int
  id: Int
  roundId: Int
  tick: Int
  victimId: Int
}

# order by min() on columns of table "player_blind"
input player_blind_min_order_by {
  attackerId: order_by
  duration: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# ordering options when selecting data from "player_blind"
input player_blind_order_by {
  attacker: player_info_order_by
  attackerId: order_by
  createdAt: order_by
  duration: order_by
  id: order_by
  round: round_order_by
  roundId: order_by
  tick: order_by
  victim: player_info_order_by
  victimId: order_by
}

# select columns of table "player_blind"
enum player_blind_select_column {
  # column name
  attackerId

  # column name
  createdAt

  # column name
  duration

  # column name
  id

  # column name
  roundId

  # column name
  tick

  # column name
  victimId
}

# aggregate stddev on columns
type player_blind_stddev_fields {
  attackerId: Float
  duration: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by stddev() on columns of table "player_blind"
input player_blind_stddev_order_by {
  attackerId: order_by
  duration: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate stddev_pop on columns
type player_blind_stddev_pop_fields {
  attackerId: Float
  duration: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by stddev_pop() on columns of table "player_blind"
input player_blind_stddev_pop_order_by {
  attackerId: order_by
  duration: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate stddev_samp on columns
type player_blind_stddev_samp_fields {
  attackerId: Float
  duration: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by stddev_samp() on columns of table "player_blind"
input player_blind_stddev_samp_order_by {
  attackerId: order_by
  duration: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate sum on columns
type player_blind_sum_fields {
  attackerId: Int
  duration: Int
  id: Int
  roundId: Int
  tick: Int
  victimId: Int
}

# order by sum() on columns of table "player_blind"
input player_blind_sum_order_by {
  attackerId: order_by
  duration: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate var_pop on columns
type player_blind_var_pop_fields {
  attackerId: Float
  duration: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by var_pop() on columns of table "player_blind"
input player_blind_var_pop_order_by {
  attackerId: order_by
  duration: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate var_samp on columns
type player_blind_var_samp_fields {
  attackerId: Float
  duration: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by var_samp() on columns of table "player_blind"
input player_blind_var_samp_order_by {
  attackerId: order_by
  duration: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# aggregate variance on columns
type player_blind_variance_fields {
  attackerId: Float
  duration: Float
  id: Float
  roundId: Float
  tick: Float
  victimId: Float
}

# order by variance() on columns of table "player_blind"
input player_blind_variance_order_by {
  attackerId: order_by
  duration: order_by
  id: order_by
  roundId: order_by
  tick: order_by
  victimId: order_by
}

# Boolean expression to filter rows from the table "player". All fields are combined with a logical 'AND'.
input player_bool_exp {
  _and: [player_bool_exp]
  _not: player_bool_exp
  _or: [player_bool_exp]
  bans: ban_bool_exp
  createdAt: timestamp_comparison_exp
  followedBy: player_followed_by_user_bool_exp
  id: Int_comparison_exp
  lastCheckedAt: timestamp_comparison_exp
  matches: match_players_player_bool_exp
  player_infos: player_info_bool_exp
  steamAvatar: String_comparison_exp
  steamId: String_comparison_exp
  steamProfile: String_comparison_exp
  steamUsername: String_comparison_exp
  teams: team_players_player_bool_exp
  trackedBy: player_tracked_by_user_bool_exp
}

# columns and relationships of "player_followed_by_user"
type player_followed_by_user {
  # An object relationship
  player: player!
  playerId: Int!

  # An object relationship
  user: user!
  userId: Int!
}

# aggregated selection of "player_followed_by_user"
type player_followed_by_user_aggregate {
  aggregate: player_followed_by_user_aggregate_fields
  nodes: [player_followed_by_user!]!
}

# aggregate fields of "player_followed_by_user"
type player_followed_by_user_aggregate_fields {
  avg: player_followed_by_user_avg_fields
  count(columns: [player_followed_by_user_select_column!], distinct: Boolean): Int
  max: player_followed_by_user_max_fields
  min: player_followed_by_user_min_fields
  stddev: player_followed_by_user_stddev_fields
  stddev_pop: player_followed_by_user_stddev_pop_fields
  stddev_samp: player_followed_by_user_stddev_samp_fields
  sum: player_followed_by_user_sum_fields
  var_pop: player_followed_by_user_var_pop_fields
  var_samp: player_followed_by_user_var_samp_fields
  variance: player_followed_by_user_variance_fields
}

# order by aggregate values of table "player_followed_by_user"
input player_followed_by_user_aggregate_order_by {
  avg: player_followed_by_user_avg_order_by
  count: order_by
  max: player_followed_by_user_max_order_by
  min: player_followed_by_user_min_order_by
  stddev: player_followed_by_user_stddev_order_by
  stddev_pop: player_followed_by_user_stddev_pop_order_by
  stddev_samp: player_followed_by_user_stddev_samp_order_by
  sum: player_followed_by_user_sum_order_by
  var_pop: player_followed_by_user_var_pop_order_by
  var_samp: player_followed_by_user_var_samp_order_by
  variance: player_followed_by_user_variance_order_by
}

# aggregate avg on columns
type player_followed_by_user_avg_fields {
  playerId: Float
  userId: Float
}

# order by avg() on columns of table "player_followed_by_user"
input player_followed_by_user_avg_order_by {
  playerId: order_by
  userId: order_by
}

# Boolean expression to filter rows from the table "player_followed_by_user". All fields are combined with a logical 'AND'.
input player_followed_by_user_bool_exp {
  _and: [player_followed_by_user_bool_exp]
  _not: player_followed_by_user_bool_exp
  _or: [player_followed_by_user_bool_exp]
  player: player_bool_exp
  playerId: Int_comparison_exp
  user: user_bool_exp
  userId: Int_comparison_exp
}

# aggregate max on columns
type player_followed_by_user_max_fields {
  playerId: Int
  userId: Int
}

# order by max() on columns of table "player_followed_by_user"
input player_followed_by_user_max_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate min on columns
type player_followed_by_user_min_fields {
  playerId: Int
  userId: Int
}

# order by min() on columns of table "player_followed_by_user"
input player_followed_by_user_min_order_by {
  playerId: order_by
  userId: order_by
}

# ordering options when selecting data from "player_followed_by_user"
input player_followed_by_user_order_by {
  player: player_order_by
  playerId: order_by
  user: user_order_by
  userId: order_by
}

# select columns of table "player_followed_by_user"
enum player_followed_by_user_select_column {
  # column name
  playerId

  # column name
  userId
}

# aggregate stddev on columns
type player_followed_by_user_stddev_fields {
  playerId: Float
  userId: Float
}

# order by stddev() on columns of table "player_followed_by_user"
input player_followed_by_user_stddev_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate stddev_pop on columns
type player_followed_by_user_stddev_pop_fields {
  playerId: Float
  userId: Float
}

# order by stddev_pop() on columns of table "player_followed_by_user"
input player_followed_by_user_stddev_pop_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate stddev_samp on columns
type player_followed_by_user_stddev_samp_fields {
  playerId: Float
  userId: Float
}

# order by stddev_samp() on columns of table "player_followed_by_user"
input player_followed_by_user_stddev_samp_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate sum on columns
type player_followed_by_user_sum_fields {
  playerId: Int
  userId: Int
}

# order by sum() on columns of table "player_followed_by_user"
input player_followed_by_user_sum_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate var_pop on columns
type player_followed_by_user_var_pop_fields {
  playerId: Float
  userId: Float
}

# order by var_pop() on columns of table "player_followed_by_user"
input player_followed_by_user_var_pop_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate var_samp on columns
type player_followed_by_user_var_samp_fields {
  playerId: Float
  userId: Float
}

# order by var_samp() on columns of table "player_followed_by_user"
input player_followed_by_user_var_samp_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate variance on columns
type player_followed_by_user_variance_fields {
  playerId: Float
  userId: Float
}

# order by variance() on columns of table "player_followed_by_user"
input player_followed_by_user_variance_order_by {
  playerId: order_by
  userId: order_by
}

# columns and relationships of "player_hurt"
type player_hurt {
  # An object relationship
  attacker: player_info
  attackerId: Int
  createdAt: timestamp!
  damageArmour: Int!
  damageHealth: Int!
  hitGroup: Int!
  id: Int!

  # An object relationship
  round: round
  roundId: Int
  source: Int!
  tick: Int!

  # An object relationship
  victim: player_info
  victimId: Int
}

# aggregated selection of "player_hurt"
type player_hurt_aggregate {
  aggregate: player_hurt_aggregate_fields
  nodes: [player_hurt!]!
}

# aggregate fields of "player_hurt"
type player_hurt_aggregate_fields {
  avg: player_hurt_avg_fields
  count(columns: [player_hurt_select_column!], distinct: Boolean): Int
  max: player_hurt_max_fields
  min: player_hurt_min_fields
  stddev: player_hurt_stddev_fields
  stddev_pop: player_hurt_stddev_pop_fields
  stddev_samp: player_hurt_stddev_samp_fields
  sum: player_hurt_sum_fields
  var_pop: player_hurt_var_pop_fields
  var_samp: player_hurt_var_samp_fields
  variance: player_hurt_variance_fields
}

# order by aggregate values of table "player_hurt"
input player_hurt_aggregate_order_by {
  avg: player_hurt_avg_order_by
  count: order_by
  max: player_hurt_max_order_by
  min: player_hurt_min_order_by
  stddev: player_hurt_stddev_order_by
  stddev_pop: player_hurt_stddev_pop_order_by
  stddev_samp: player_hurt_stddev_samp_order_by
  sum: player_hurt_sum_order_by
  var_pop: player_hurt_var_pop_order_by
  var_samp: player_hurt_var_samp_order_by
  variance: player_hurt_variance_order_by
}

# aggregate avg on columns
type player_hurt_avg_fields {
  attackerId: Float
  damageArmour: Float
  damageHealth: Float
  hitGroup: Float
  id: Float
  roundId: Float
  source: Float
  tick: Float
  victimId: Float
}

# order by avg() on columns of table "player_hurt"
input player_hurt_avg_order_by {
  attackerId: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victimId: order_by
}

# Boolean expression to filter rows from the table "player_hurt". All fields are combined with a logical 'AND'.
input player_hurt_bool_exp {
  _and: [player_hurt_bool_exp]
  _not: player_hurt_bool_exp
  _or: [player_hurt_bool_exp]
  attacker: player_info_bool_exp
  attackerId: Int_comparison_exp
  createdAt: timestamp_comparison_exp
  damageArmour: Int_comparison_exp
  damageHealth: Int_comparison_exp
  hitGroup: Int_comparison_exp
  id: Int_comparison_exp
  round: round_bool_exp
  roundId: Int_comparison_exp
  source: Int_comparison_exp
  tick: Int_comparison_exp
  victim: player_info_bool_exp
  victimId: Int_comparison_exp
}

# aggregate max on columns
type player_hurt_max_fields {
  attackerId: Int
  damageArmour: Int
  damageHealth: Int
  hitGroup: Int
  id: Int
  roundId: Int
  source: Int
  tick: Int
  victimId: Int
}

# order by max() on columns of table "player_hurt"
input player_hurt_max_order_by {
  attackerId: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victimId: order_by
}

# aggregate min on columns
type player_hurt_min_fields {
  attackerId: Int
  damageArmour: Int
  damageHealth: Int
  hitGroup: Int
  id: Int
  roundId: Int
  source: Int
  tick: Int
  victimId: Int
}

# order by min() on columns of table "player_hurt"
input player_hurt_min_order_by {
  attackerId: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victimId: order_by
}

# ordering options when selecting data from "player_hurt"
input player_hurt_order_by {
  attacker: player_info_order_by
  attackerId: order_by
  createdAt: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  round: round_order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victim: player_info_order_by
  victimId: order_by
}

# select columns of table "player_hurt"
enum player_hurt_select_column {
  # column name
  attackerId

  # column name
  createdAt

  # column name
  damageArmour

  # column name
  damageHealth

  # column name
  hitGroup

  # column name
  id

  # column name
  roundId

  # column name
  source

  # column name
  tick

  # column name
  victimId
}

# aggregate stddev on columns
type player_hurt_stddev_fields {
  attackerId: Float
  damageArmour: Float
  damageHealth: Float
  hitGroup: Float
  id: Float
  roundId: Float
  source: Float
  tick: Float
  victimId: Float
}

# order by stddev() on columns of table "player_hurt"
input player_hurt_stddev_order_by {
  attackerId: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victimId: order_by
}

# aggregate stddev_pop on columns
type player_hurt_stddev_pop_fields {
  attackerId: Float
  damageArmour: Float
  damageHealth: Float
  hitGroup: Float
  id: Float
  roundId: Float
  source: Float
  tick: Float
  victimId: Float
}

# order by stddev_pop() on columns of table "player_hurt"
input player_hurt_stddev_pop_order_by {
  attackerId: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victimId: order_by
}

# aggregate stddev_samp on columns
type player_hurt_stddev_samp_fields {
  attackerId: Float
  damageArmour: Float
  damageHealth: Float
  hitGroup: Float
  id: Float
  roundId: Float
  source: Float
  tick: Float
  victimId: Float
}

# order by stddev_samp() on columns of table "player_hurt"
input player_hurt_stddev_samp_order_by {
  attackerId: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victimId: order_by
}

# aggregate sum on columns
type player_hurt_sum_fields {
  attackerId: Int
  damageArmour: Int
  damageHealth: Int
  hitGroup: Int
  id: Int
  roundId: Int
  source: Int
  tick: Int
  victimId: Int
}

# order by sum() on columns of table "player_hurt"
input player_hurt_sum_order_by {
  attackerId: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victimId: order_by
}

# aggregate var_pop on columns
type player_hurt_var_pop_fields {
  attackerId: Float
  damageArmour: Float
  damageHealth: Float
  hitGroup: Float
  id: Float
  roundId: Float
  source: Float
  tick: Float
  victimId: Float
}

# order by var_pop() on columns of table "player_hurt"
input player_hurt_var_pop_order_by {
  attackerId: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victimId: order_by
}

# aggregate var_samp on columns
type player_hurt_var_samp_fields {
  attackerId: Float
  damageArmour: Float
  damageHealth: Float
  hitGroup: Float
  id: Float
  roundId: Float
  source: Float
  tick: Float
  victimId: Float
}

# order by var_samp() on columns of table "player_hurt"
input player_hurt_var_samp_order_by {
  attackerId: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victimId: order_by
}

# aggregate variance on columns
type player_hurt_variance_fields {
  attackerId: Float
  damageArmour: Float
  damageHealth: Float
  hitGroup: Float
  id: Float
  roundId: Float
  source: Float
  tick: Float
  victimId: Float
}

# order by variance() on columns of table "player_hurt"
input player_hurt_variance_order_by {
  attackerId: order_by
  damageArmour: order_by
  damageHealth: order_by
  hitGroup: order_by
  id: order_by
  roundId: order_by
  source: order_by
  tick: order_by
  victimId: order_by
}

# columns and relationships of "player_info"
type player_info {
  armour: Int!
  bulletsInMagazine: Int!
  cashSpentInRound: Int!
  createdAt: timestamp!
  equipmentValue: Int!
  freezeTimeEndEquipmentValue: Int!
  hasC4: Boolean!
  health: Int!
  id: Int!
  isScoped: Boolean!

  # An object relationship
  player: player
  playerId: Int
  tick: Int!
  weapon: player_info_weapon_enum!
}

# aggregated selection of "player_info"
type player_info_aggregate {
  aggregate: player_info_aggregate_fields
  nodes: [player_info!]!
}

# aggregate fields of "player_info"
type player_info_aggregate_fields {
  avg: player_info_avg_fields
  count(columns: [player_info_select_column!], distinct: Boolean): Int
  max: player_info_max_fields
  min: player_info_min_fields
  stddev: player_info_stddev_fields
  stddev_pop: player_info_stddev_pop_fields
  stddev_samp: player_info_stddev_samp_fields
  sum: player_info_sum_fields
  var_pop: player_info_var_pop_fields
  var_samp: player_info_var_samp_fields
  variance: player_info_variance_fields
}

# order by aggregate values of table "player_info"
input player_info_aggregate_order_by {
  avg: player_info_avg_order_by
  count: order_by
  max: player_info_max_order_by
  min: player_info_min_order_by
  stddev: player_info_stddev_order_by
  stddev_pop: player_info_stddev_pop_order_by
  stddev_samp: player_info_stddev_samp_order_by
  sum: player_info_sum_order_by
  var_pop: player_info_var_pop_order_by
  var_samp: player_info_var_samp_order_by
  variance: player_info_variance_order_by
}

# aggregate avg on columns
type player_info_avg_fields {
  armour: Float
  bulletsInMagazine: Float
  cashSpentInRound: Float
  equipmentValue: Float
  freezeTimeEndEquipmentValue: Float
  health: Float
  id: Float
  playerId: Float
  tick: Float
}

# order by avg() on columns of table "player_info"
input player_info_avg_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  health: order_by
  id: order_by
  playerId: order_by
  tick: order_by
}

# Boolean expression to filter rows from the table "player_info". All fields are combined with a logical 'AND'.
input player_info_bool_exp {
  _and: [player_info_bool_exp]
  _not: player_info_bool_exp
  _or: [player_info_bool_exp]
  armour: Int_comparison_exp
  bulletsInMagazine: Int_comparison_exp
  cashSpentInRound: Int_comparison_exp
  createdAt: timestamp_comparison_exp
  equipmentValue: Int_comparison_exp
  freezeTimeEndEquipmentValue: Int_comparison_exp
  hasC4: Boolean_comparison_exp
  health: Int_comparison_exp
  id: Int_comparison_exp
  isScoped: Boolean_comparison_exp
  player: player_bool_exp
  playerId: Int_comparison_exp
  tick: Int_comparison_exp
  weapon: player_info_weapon_enum_comparison_exp
}

# aggregate max on columns
type player_info_max_fields {
  armour: Int
  bulletsInMagazine: Int
  cashSpentInRound: Int
  equipmentValue: Int
  freezeTimeEndEquipmentValue: Int
  health: Int
  id: Int
  playerId: Int
  tick: Int
}

# order by max() on columns of table "player_info"
input player_info_max_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  health: order_by
  id: order_by
  playerId: order_by
  tick: order_by
}

# aggregate min on columns
type player_info_min_fields {
  armour: Int
  bulletsInMagazine: Int
  cashSpentInRound: Int
  equipmentValue: Int
  freezeTimeEndEquipmentValue: Int
  health: Int
  id: Int
  playerId: Int
  tick: Int
}

# order by min() on columns of table "player_info"
input player_info_min_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  health: order_by
  id: order_by
  playerId: order_by
  tick: order_by
}

# ordering options when selecting data from "player_info"
input player_info_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  createdAt: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  hasC4: order_by
  health: order_by
  id: order_by
  isScoped: order_by
  player: player_order_by
  playerId: order_by
  tick: order_by
  weapon: order_by
}

# select columns of table "player_info"
enum player_info_select_column {
  # column name
  armour

  # column name
  bulletsInMagazine

  # column name
  cashSpentInRound

  # column name
  createdAt

  # column name
  equipmentValue

  # column name
  freezeTimeEndEquipmentValue

  # column name
  hasC4

  # column name
  health

  # column name
  id

  # column name
  isScoped

  # column name
  playerId

  # column name
  tick

  # column name
  weapon
}

# aggregate stddev on columns
type player_info_stddev_fields {
  armour: Float
  bulletsInMagazine: Float
  cashSpentInRound: Float
  equipmentValue: Float
  freezeTimeEndEquipmentValue: Float
  health: Float
  id: Float
  playerId: Float
  tick: Float
}

# order by stddev() on columns of table "player_info"
input player_info_stddev_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  health: order_by
  id: order_by
  playerId: order_by
  tick: order_by
}

# aggregate stddev_pop on columns
type player_info_stddev_pop_fields {
  armour: Float
  bulletsInMagazine: Float
  cashSpentInRound: Float
  equipmentValue: Float
  freezeTimeEndEquipmentValue: Float
  health: Float
  id: Float
  playerId: Float
  tick: Float
}

# order by stddev_pop() on columns of table "player_info"
input player_info_stddev_pop_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  health: order_by
  id: order_by
  playerId: order_by
  tick: order_by
}

# aggregate stddev_samp on columns
type player_info_stddev_samp_fields {
  armour: Float
  bulletsInMagazine: Float
  cashSpentInRound: Float
  equipmentValue: Float
  freezeTimeEndEquipmentValue: Float
  health: Float
  id: Float
  playerId: Float
  tick: Float
}

# order by stddev_samp() on columns of table "player_info"
input player_info_stddev_samp_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  health: order_by
  id: order_by
  playerId: order_by
  tick: order_by
}

# aggregate sum on columns
type player_info_sum_fields {
  armour: Int
  bulletsInMagazine: Int
  cashSpentInRound: Int
  equipmentValue: Int
  freezeTimeEndEquipmentValue: Int
  health: Int
  id: Int
  playerId: Int
  tick: Int
}

# order by sum() on columns of table "player_info"
input player_info_sum_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  health: order_by
  id: order_by
  playerId: order_by
  tick: order_by
}

# aggregate var_pop on columns
type player_info_var_pop_fields {
  armour: Float
  bulletsInMagazine: Float
  cashSpentInRound: Float
  equipmentValue: Float
  freezeTimeEndEquipmentValue: Float
  health: Float
  id: Float
  playerId: Float
  tick: Float
}

# order by var_pop() on columns of table "player_info"
input player_info_var_pop_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  health: order_by
  id: order_by
  playerId: order_by
  tick: order_by
}

# aggregate var_samp on columns
type player_info_var_samp_fields {
  armour: Float
  bulletsInMagazine: Float
  cashSpentInRound: Float
  equipmentValue: Float
  freezeTimeEndEquipmentValue: Float
  health: Float
  id: Float
  playerId: Float
  tick: Float
}

# order by var_samp() on columns of table "player_info"
input player_info_var_samp_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  health: order_by
  id: order_by
  playerId: order_by
  tick: order_by
}

# aggregate variance on columns
type player_info_variance_fields {
  armour: Float
  bulletsInMagazine: Float
  cashSpentInRound: Float
  equipmentValue: Float
  freezeTimeEndEquipmentValue: Float
  health: Float
  id: Float
  playerId: Float
  tick: Float
}

# order by variance() on columns of table "player_info"
input player_info_variance_order_by {
  armour: order_by
  bulletsInMagazine: order_by
  cashSpentInRound: order_by
  equipmentValue: order_by
  freezeTimeEndEquipmentValue: order_by
  health: order_by
  id: order_by
  playerId: order_by
  tick: order_by
}

scalar player_info_weapon_enum

# expression to compare columns of type player_info_weapon_enum. All fields are combined with logical 'AND'.
input player_info_weapon_enum_comparison_exp {
  _eq: player_info_weapon_enum
  _gt: player_info_weapon_enum
  _gte: player_info_weapon_enum
  _in: [player_info_weapon_enum!]
  _is_null: Boolean
  _lt: player_info_weapon_enum
  _lte: player_info_weapon_enum
  _neq: player_info_weapon_enum
  _nin: [player_info_weapon_enum!]
}

# columns and relationships of "player_jump"
type player_jump {
  createdAt: timestamp!
  id: Int!

  # An object relationship
  player: player_info
  playerId: Int

  # An object relationship
  round: round
  roundId: Int
  tick: Int!
}

# aggregated selection of "player_jump"
type player_jump_aggregate {
  aggregate: player_jump_aggregate_fields
  nodes: [player_jump!]!
}

# aggregate fields of "player_jump"
type player_jump_aggregate_fields {
  avg: player_jump_avg_fields
  count(columns: [player_jump_select_column!], distinct: Boolean): Int
  max: player_jump_max_fields
  min: player_jump_min_fields
  stddev: player_jump_stddev_fields
  stddev_pop: player_jump_stddev_pop_fields
  stddev_samp: player_jump_stddev_samp_fields
  sum: player_jump_sum_fields
  var_pop: player_jump_var_pop_fields
  var_samp: player_jump_var_samp_fields
  variance: player_jump_variance_fields
}

# order by aggregate values of table "player_jump"
input player_jump_aggregate_order_by {
  avg: player_jump_avg_order_by
  count: order_by
  max: player_jump_max_order_by
  min: player_jump_min_order_by
  stddev: player_jump_stddev_order_by
  stddev_pop: player_jump_stddev_pop_order_by
  stddev_samp: player_jump_stddev_samp_order_by
  sum: player_jump_sum_order_by
  var_pop: player_jump_var_pop_order_by
  var_samp: player_jump_var_samp_order_by
  variance: player_jump_variance_order_by
}

# aggregate avg on columns
type player_jump_avg_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
}

# order by avg() on columns of table "player_jump"
input player_jump_avg_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
}

# Boolean expression to filter rows from the table "player_jump". All fields are combined with a logical 'AND'.
input player_jump_bool_exp {
  _and: [player_jump_bool_exp]
  _not: player_jump_bool_exp
  _or: [player_jump_bool_exp]
  createdAt: timestamp_comparison_exp
  id: Int_comparison_exp
  player: player_info_bool_exp
  playerId: Int_comparison_exp
  round: round_bool_exp
  roundId: Int_comparison_exp
  tick: Int_comparison_exp
}

# aggregate max on columns
type player_jump_max_fields {
  id: Int
  playerId: Int
  roundId: Int
  tick: Int
}

# order by max() on columns of table "player_jump"
input player_jump_max_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate min on columns
type player_jump_min_fields {
  id: Int
  playerId: Int
  roundId: Int
  tick: Int
}

# order by min() on columns of table "player_jump"
input player_jump_min_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
}

# ordering options when selecting data from "player_jump"
input player_jump_order_by {
  createdAt: order_by
  id: order_by
  player: player_info_order_by
  playerId: order_by
  round: round_order_by
  roundId: order_by
  tick: order_by
}

# select columns of table "player_jump"
enum player_jump_select_column {
  # column name
  createdAt

  # column name
  id

  # column name
  playerId

  # column name
  roundId

  # column name
  tick
}

# aggregate stddev on columns
type player_jump_stddev_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
}

# order by stddev() on columns of table "player_jump"
input player_jump_stddev_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate stddev_pop on columns
type player_jump_stddev_pop_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
}

# order by stddev_pop() on columns of table "player_jump"
input player_jump_stddev_pop_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate stddev_samp on columns
type player_jump_stddev_samp_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
}

# order by stddev_samp() on columns of table "player_jump"
input player_jump_stddev_samp_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate sum on columns
type player_jump_sum_fields {
  id: Int
  playerId: Int
  roundId: Int
  tick: Int
}

# order by sum() on columns of table "player_jump"
input player_jump_sum_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate var_pop on columns
type player_jump_var_pop_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
}

# order by var_pop() on columns of table "player_jump"
input player_jump_var_pop_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate var_samp on columns
type player_jump_var_samp_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
}

# order by var_samp() on columns of table "player_jump"
input player_jump_var_samp_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate variance on columns
type player_jump_variance_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
}

# order by variance() on columns of table "player_jump"
input player_jump_variance_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate max on columns
type player_max_fields {
  id: Int
  steamAvatar: String
  steamId: String
  steamProfile: String
  steamUsername: String
}

# order by max() on columns of table "player"
input player_max_order_by {
  id: order_by
  steamAvatar: order_by
  steamId: order_by
  steamProfile: order_by
  steamUsername: order_by
}

# aggregate min on columns
type player_min_fields {
  id: Int
  steamAvatar: String
  steamId: String
  steamProfile: String
  steamUsername: String
}

# order by min() on columns of table "player"
input player_min_order_by {
  id: order_by
  steamAvatar: order_by
  steamId: order_by
  steamProfile: order_by
  steamUsername: order_by
}

# ordering options when selecting data from "player"
input player_order_by {
  bans_aggregate: ban_aggregate_order_by
  createdAt: order_by
  followedBy_aggregate: player_followed_by_user_aggregate_order_by
  id: order_by
  lastCheckedAt: order_by
  matches_aggregate: match_players_player_aggregate_order_by
  player_infos_aggregate: player_info_aggregate_order_by
  steamAvatar: order_by
  steamId: order_by
  steamProfile: order_by
  steamUsername: order_by
  teams_aggregate: team_players_player_aggregate_order_by
  trackedBy_aggregate: player_tracked_by_user_aggregate_order_by
}

# select columns of table "player"
enum player_select_column {
  # column name
  createdAt

  # column name
  id

  # column name
  lastCheckedAt

  # column name
  steamAvatar

  # column name
  steamId

  # column name
  steamProfile

  # column name
  steamUsername
}

# aggregate stddev on columns
type player_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "player"
input player_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type player_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "player"
input player_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type player_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "player"
input player_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type player_sum_fields {
  id: Int
}

# order by sum() on columns of table "player"
input player_sum_order_by {
  id: order_by
}

# columns and relationships of "player_tracked_by_user"
type player_tracked_by_user {
  # An object relationship
  player: player!
  playerId: Int!

  # An object relationship
  user: user!
  userId: Int!
}

# aggregated selection of "player_tracked_by_user"
type player_tracked_by_user_aggregate {
  aggregate: player_tracked_by_user_aggregate_fields
  nodes: [player_tracked_by_user!]!
}

# aggregate fields of "player_tracked_by_user"
type player_tracked_by_user_aggregate_fields {
  avg: player_tracked_by_user_avg_fields
  count(columns: [player_tracked_by_user_select_column!], distinct: Boolean): Int
  max: player_tracked_by_user_max_fields
  min: player_tracked_by_user_min_fields
  stddev: player_tracked_by_user_stddev_fields
  stddev_pop: player_tracked_by_user_stddev_pop_fields
  stddev_samp: player_tracked_by_user_stddev_samp_fields
  sum: player_tracked_by_user_sum_fields
  var_pop: player_tracked_by_user_var_pop_fields
  var_samp: player_tracked_by_user_var_samp_fields
  variance: player_tracked_by_user_variance_fields
}

# order by aggregate values of table "player_tracked_by_user"
input player_tracked_by_user_aggregate_order_by {
  avg: player_tracked_by_user_avg_order_by
  count: order_by
  max: player_tracked_by_user_max_order_by
  min: player_tracked_by_user_min_order_by
  stddev: player_tracked_by_user_stddev_order_by
  stddev_pop: player_tracked_by_user_stddev_pop_order_by
  stddev_samp: player_tracked_by_user_stddev_samp_order_by
  sum: player_tracked_by_user_sum_order_by
  var_pop: player_tracked_by_user_var_pop_order_by
  var_samp: player_tracked_by_user_var_samp_order_by
  variance: player_tracked_by_user_variance_order_by
}

# aggregate avg on columns
type player_tracked_by_user_avg_fields {
  playerId: Float
  userId: Float
}

# order by avg() on columns of table "player_tracked_by_user"
input player_tracked_by_user_avg_order_by {
  playerId: order_by
  userId: order_by
}

# Boolean expression to filter rows from the table "player_tracked_by_user". All fields are combined with a logical 'AND'.
input player_tracked_by_user_bool_exp {
  _and: [player_tracked_by_user_bool_exp]
  _not: player_tracked_by_user_bool_exp
  _or: [player_tracked_by_user_bool_exp]
  player: player_bool_exp
  playerId: Int_comparison_exp
  user: user_bool_exp
  userId: Int_comparison_exp
}

# aggregate max on columns
type player_tracked_by_user_max_fields {
  playerId: Int
  userId: Int
}

# order by max() on columns of table "player_tracked_by_user"
input player_tracked_by_user_max_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate min on columns
type player_tracked_by_user_min_fields {
  playerId: Int
  userId: Int
}

# order by min() on columns of table "player_tracked_by_user"
input player_tracked_by_user_min_order_by {
  playerId: order_by
  userId: order_by
}

# ordering options when selecting data from "player_tracked_by_user"
input player_tracked_by_user_order_by {
  player: player_order_by
  playerId: order_by
  user: user_order_by
  userId: order_by
}

# select columns of table "player_tracked_by_user"
enum player_tracked_by_user_select_column {
  # column name
  playerId

  # column name
  userId
}

# aggregate stddev on columns
type player_tracked_by_user_stddev_fields {
  playerId: Float
  userId: Float
}

# order by stddev() on columns of table "player_tracked_by_user"
input player_tracked_by_user_stddev_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate stddev_pop on columns
type player_tracked_by_user_stddev_pop_fields {
  playerId: Float
  userId: Float
}

# order by stddev_pop() on columns of table "player_tracked_by_user"
input player_tracked_by_user_stddev_pop_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate stddev_samp on columns
type player_tracked_by_user_stddev_samp_fields {
  playerId: Float
  userId: Float
}

# order by stddev_samp() on columns of table "player_tracked_by_user"
input player_tracked_by_user_stddev_samp_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate sum on columns
type player_tracked_by_user_sum_fields {
  playerId: Int
  userId: Int
}

# order by sum() on columns of table "player_tracked_by_user"
input player_tracked_by_user_sum_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate var_pop on columns
type player_tracked_by_user_var_pop_fields {
  playerId: Float
  userId: Float
}

# order by var_pop() on columns of table "player_tracked_by_user"
input player_tracked_by_user_var_pop_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate var_samp on columns
type player_tracked_by_user_var_samp_fields {
  playerId: Float
  userId: Float
}

# order by var_samp() on columns of table "player_tracked_by_user"
input player_tracked_by_user_var_samp_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate variance on columns
type player_tracked_by_user_variance_fields {
  playerId: Float
  userId: Float
}

# order by variance() on columns of table "player_tracked_by_user"
input player_tracked_by_user_variance_order_by {
  playerId: order_by
  userId: order_by
}

# aggregate var_pop on columns
type player_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "player"
input player_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type player_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "player"
input player_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type player_variance_fields {
  id: Float
}

# order by variance() on columns of table "player"
input player_variance_order_by {
  id: order_by
}

# columns and relationships of "position"
type position {
  createdAt: timestamp!
  id: Int!
  x: Int!
  y: Int!
  z: Int!
}

# aggregated selection of "position"
type position_aggregate {
  aggregate: position_aggregate_fields
  nodes: [position!]!
}

# aggregate fields of "position"
type position_aggregate_fields {
  avg: position_avg_fields
  count(columns: [position_select_column!], distinct: Boolean): Int
  max: position_max_fields
  min: position_min_fields
  stddev: position_stddev_fields
  stddev_pop: position_stddev_pop_fields
  stddev_samp: position_stddev_samp_fields
  sum: position_sum_fields
  var_pop: position_var_pop_fields
  var_samp: position_var_samp_fields
  variance: position_variance_fields
}

# order by aggregate values of table "position"
input position_aggregate_order_by {
  avg: position_avg_order_by
  count: order_by
  max: position_max_order_by
  min: position_min_order_by
  stddev: position_stddev_order_by
  stddev_pop: position_stddev_pop_order_by
  stddev_samp: position_stddev_samp_order_by
  sum: position_sum_order_by
  var_pop: position_var_pop_order_by
  var_samp: position_var_samp_order_by
  variance: position_variance_order_by
}

# aggregate avg on columns
type position_avg_fields {
  id: Float
  x: Float
  y: Float
  z: Float
}

# order by avg() on columns of table "position"
input position_avg_order_by {
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# Boolean expression to filter rows from the table "position". All fields are combined with a logical 'AND'.
input position_bool_exp {
  _and: [position_bool_exp]
  _not: position_bool_exp
  _or: [position_bool_exp]
  createdAt: timestamp_comparison_exp
  id: Int_comparison_exp
  x: Int_comparison_exp
  y: Int_comparison_exp
  z: Int_comparison_exp
}

# aggregate max on columns
type position_max_fields {
  id: Int
  x: Int
  y: Int
  z: Int
}

# order by max() on columns of table "position"
input position_max_order_by {
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# aggregate min on columns
type position_min_fields {
  id: Int
  x: Int
  y: Int
  z: Int
}

# order by min() on columns of table "position"
input position_min_order_by {
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# ordering options when selecting data from "position"
input position_order_by {
  createdAt: order_by
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# select columns of table "position"
enum position_select_column {
  # column name
  createdAt

  # column name
  id

  # column name
  x

  # column name
  y

  # column name
  z
}

# aggregate stddev on columns
type position_stddev_fields {
  id: Float
  x: Float
  y: Float
  z: Float
}

# order by stddev() on columns of table "position"
input position_stddev_order_by {
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# aggregate stddev_pop on columns
type position_stddev_pop_fields {
  id: Float
  x: Float
  y: Float
  z: Float
}

# order by stddev_pop() on columns of table "position"
input position_stddev_pop_order_by {
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# aggregate stddev_samp on columns
type position_stddev_samp_fields {
  id: Float
  x: Float
  y: Float
  z: Float
}

# order by stddev_samp() on columns of table "position"
input position_stddev_samp_order_by {
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# aggregate sum on columns
type position_sum_fields {
  id: Int
  x: Int
  y: Int
  z: Int
}

# order by sum() on columns of table "position"
input position_sum_order_by {
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# aggregate var_pop on columns
type position_var_pop_fields {
  id: Float
  x: Float
  y: Float
  z: Float
}

# order by var_pop() on columns of table "position"
input position_var_pop_order_by {
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# aggregate var_samp on columns
type position_var_samp_fields {
  id: Float
  x: Float
  y: Float
  z: Float
}

# order by var_samp() on columns of table "position"
input position_var_samp_order_by {
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# aggregate variance on columns
type position_variance_fields {
  id: Float
  x: Float
  y: Float
  z: Float
}

# order by variance() on columns of table "position"
input position_variance_order_by {
  id: order_by
  x: order_by
  y: order_by
  z: order_by
}

# query root
type query_root {
  # fetch data from the table: "ban"
  ban(
    # distinct select on columns
    distinct_on: [ban_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [ban_order_by!]

    # filter the rows returned
    where: ban_bool_exp
  ): [ban!]!

  # fetch aggregated fields from the table: "ban"
  ban_aggregate(
    # distinct select on columns
    distinct_on: [ban_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [ban_order_by!]

    # filter the rows returned
    where: ban_bool_exp
  ): ban_aggregate!

  # fetch data from the table: "ban" using primary key columns
  ban_by_pk(id: Int!): ban

  # fetch data from the table: "bomb_status"
  bomb_status(
    # distinct select on columns
    distinct_on: [bomb_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [bomb_status_order_by!]

    # filter the rows returned
    where: bomb_status_bool_exp
  ): [bomb_status!]!

  # fetch aggregated fields from the table: "bomb_status"
  bomb_status_aggregate(
    # distinct select on columns
    distinct_on: [bomb_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [bomb_status_order_by!]

    # filter the rows returned
    where: bomb_status_bool_exp
  ): bomb_status_aggregate!

  # fetch data from the table: "bomb_status" using primary key columns
  bomb_status_by_pk(id: Int!): bomb_status

  # fetch data from the table: "kill"
  kill(
    # distinct select on columns
    distinct_on: [kill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kill_order_by!]

    # filter the rows returned
    where: kill_bool_exp
  ): [kill!]!

  # fetch aggregated fields from the table: "kill"
  kill_aggregate(
    # distinct select on columns
    distinct_on: [kill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kill_order_by!]

    # filter the rows returned
    where: kill_bool_exp
  ): kill_aggregate!

  # fetch data from the table: "kill" using primary key columns
  kill_by_pk(id: Int!): kill

  # fetch data from the table: "match"
  match(
    # distinct select on columns
    distinct_on: [match_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_order_by!]

    # filter the rows returned
    where: match_bool_exp
  ): [match!]!

  # fetch aggregated fields from the table: "match"
  match_aggregate(
    # distinct select on columns
    distinct_on: [match_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_order_by!]

    # filter the rows returned
    where: match_bool_exp
  ): match_aggregate!

  # fetch data from the table: "match" using primary key columns
  match_by_pk(id: Int!): match

  # fetch data from the table: "match_players_player"
  match_players_player(
    # distinct select on columns
    distinct_on: [match_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_players_player_order_by!]

    # filter the rows returned
    where: match_players_player_bool_exp
  ): [match_players_player!]!

  # fetch aggregated fields from the table: "match_players_player"
  match_players_player_aggregate(
    # distinct select on columns
    distinct_on: [match_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_players_player_order_by!]

    # filter the rows returned
    where: match_players_player_bool_exp
  ): match_players_player_aggregate!

  # fetch data from the table: "match_players_player" using primary key columns
  match_players_player_by_pk(matchId: Int!, playerId: Int!): match_players_player

  # fetch data from the table: "match_teams_team"
  match_teams_team(
    # distinct select on columns
    distinct_on: [match_teams_team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_teams_team_order_by!]

    # filter the rows returned
    where: match_teams_team_bool_exp
  ): [match_teams_team!]!

  # fetch aggregated fields from the table: "match_teams_team"
  match_teams_team_aggregate(
    # distinct select on columns
    distinct_on: [match_teams_team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_teams_team_order_by!]

    # filter the rows returned
    where: match_teams_team_bool_exp
  ): match_teams_team_aggregate!

  # fetch data from the table: "match_teams_team" using primary key columns
  match_teams_team_by_pk(matchId: Int!, teamId: Int!): match_teams_team

  # fetch data from the table: "notification"
  notification(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): [notification!]!

  # fetch aggregated fields from the table: "notification"
  notification_aggregate(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): notification_aggregate!

  # fetch data from the table: "notification_bans_ban"
  notification_bans_ban(
    # distinct select on columns
    distinct_on: [notification_bans_ban_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_bans_ban_order_by!]

    # filter the rows returned
    where: notification_bans_ban_bool_exp
  ): [notification_bans_ban!]!

  # fetch aggregated fields from the table: "notification_bans_ban"
  notification_bans_ban_aggregate(
    # distinct select on columns
    distinct_on: [notification_bans_ban_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_bans_ban_order_by!]

    # filter the rows returned
    where: notification_bans_ban_bool_exp
  ): notification_bans_ban_aggregate!

  # fetch data from the table: "notification_bans_ban" using primary key columns
  notification_bans_ban_by_pk(banId: Int!, notificationId: Int!): notification_bans_ban

  # fetch data from the table: "notification" using primary key columns
  notification_by_pk(id: Int!): notification

  # fetch data from the table: "player"
  player(
    # distinct select on columns
    distinct_on: [player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_order_by!]

    # filter the rows returned
    where: player_bool_exp
  ): [player!]!

  # fetch aggregated fields from the table: "player"
  player_aggregate(
    # distinct select on columns
    distinct_on: [player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_order_by!]

    # filter the rows returned
    where: player_bool_exp
  ): player_aggregate!

  # fetch data from the table: "player_blind"
  player_blind(
    # distinct select on columns
    distinct_on: [player_blind_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_blind_order_by!]

    # filter the rows returned
    where: player_blind_bool_exp
  ): [player_blind!]!

  # fetch aggregated fields from the table: "player_blind"
  player_blind_aggregate(
    # distinct select on columns
    distinct_on: [player_blind_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_blind_order_by!]

    # filter the rows returned
    where: player_blind_bool_exp
  ): player_blind_aggregate!

  # fetch data from the table: "player_blind" using primary key columns
  player_blind_by_pk(id: Int!): player_blind

  # fetch data from the table: "player" using primary key columns
  player_by_pk(id: Int!): player

  # fetch data from the table: "player_followed_by_user"
  player_followed_by_user(
    # distinct select on columns
    distinct_on: [player_followed_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_followed_by_user_order_by!]

    # filter the rows returned
    where: player_followed_by_user_bool_exp
  ): [player_followed_by_user!]!

  # fetch aggregated fields from the table: "player_followed_by_user"
  player_followed_by_user_aggregate(
    # distinct select on columns
    distinct_on: [player_followed_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_followed_by_user_order_by!]

    # filter the rows returned
    where: player_followed_by_user_bool_exp
  ): player_followed_by_user_aggregate!

  # fetch data from the table: "player_followed_by_user" using primary key columns
  player_followed_by_user_by_pk(playerId: Int!, userId: Int!): player_followed_by_user

  # fetch data from the table: "player_hurt"
  player_hurt(
    # distinct select on columns
    distinct_on: [player_hurt_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_hurt_order_by!]

    # filter the rows returned
    where: player_hurt_bool_exp
  ): [player_hurt!]!

  # fetch aggregated fields from the table: "player_hurt"
  player_hurt_aggregate(
    # distinct select on columns
    distinct_on: [player_hurt_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_hurt_order_by!]

    # filter the rows returned
    where: player_hurt_bool_exp
  ): player_hurt_aggregate!

  # fetch data from the table: "player_hurt" using primary key columns
  player_hurt_by_pk(id: Int!): player_hurt

  # fetch data from the table: "player_info"
  player_info(
    # distinct select on columns
    distinct_on: [player_info_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_info_order_by!]

    # filter the rows returned
    where: player_info_bool_exp
  ): [player_info!]!

  # fetch aggregated fields from the table: "player_info"
  player_info_aggregate(
    # distinct select on columns
    distinct_on: [player_info_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_info_order_by!]

    # filter the rows returned
    where: player_info_bool_exp
  ): player_info_aggregate!

  # fetch data from the table: "player_info" using primary key columns
  player_info_by_pk(id: Int!): player_info

  # fetch data from the table: "player_jump"
  player_jump(
    # distinct select on columns
    distinct_on: [player_jump_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_jump_order_by!]

    # filter the rows returned
    where: player_jump_bool_exp
  ): [player_jump!]!

  # fetch aggregated fields from the table: "player_jump"
  player_jump_aggregate(
    # distinct select on columns
    distinct_on: [player_jump_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_jump_order_by!]

    # filter the rows returned
    where: player_jump_bool_exp
  ): player_jump_aggregate!

  # fetch data from the table: "player_jump" using primary key columns
  player_jump_by_pk(id: Int!): player_jump

  # fetch data from the table: "player_tracked_by_user"
  player_tracked_by_user(
    # distinct select on columns
    distinct_on: [player_tracked_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_tracked_by_user_order_by!]

    # filter the rows returned
    where: player_tracked_by_user_bool_exp
  ): [player_tracked_by_user!]!

  # fetch aggregated fields from the table: "player_tracked_by_user"
  player_tracked_by_user_aggregate(
    # distinct select on columns
    distinct_on: [player_tracked_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_tracked_by_user_order_by!]

    # filter the rows returned
    where: player_tracked_by_user_bool_exp
  ): player_tracked_by_user_aggregate!

  # fetch data from the table: "player_tracked_by_user" using primary key columns
  player_tracked_by_user_by_pk(playerId: Int!, userId: Int!): player_tracked_by_user

  # fetch data from the table: "position"
  position(
    # distinct select on columns
    distinct_on: [position_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [position_order_by!]

    # filter the rows returned
    where: position_bool_exp
  ): [position!]!

  # fetch aggregated fields from the table: "position"
  position_aggregate(
    # distinct select on columns
    distinct_on: [position_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [position_order_by!]

    # filter the rows returned
    where: position_bool_exp
  ): position_aggregate!

  # fetch data from the table: "position" using primary key columns
  position_by_pk(id: Int!): position

  # fetch data from the table: "round"
  round(
    # distinct select on columns
    distinct_on: [round_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [round_order_by!]

    # filter the rows returned
    where: round_bool_exp
  ): [round!]!

  # fetch aggregated fields from the table: "round"
  round_aggregate(
    # distinct select on columns
    distinct_on: [round_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [round_order_by!]

    # filter the rows returned
    where: round_bool_exp
  ): round_aggregate!

  # fetch data from the table: "round" using primary key columns
  round_by_pk(id: Int!): round

  # fetch data from the table: "team"
  team(
    # distinct select on columns
    distinct_on: [team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_order_by!]

    # filter the rows returned
    where: team_bool_exp
  ): [team!]!

  # fetch aggregated fields from the table: "team"
  team_aggregate(
    # distinct select on columns
    distinct_on: [team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_order_by!]

    # filter the rows returned
    where: team_bool_exp
  ): team_aggregate!

  # fetch data from the table: "team" using primary key columns
  team_by_pk(id: Int!): team

  # fetch data from the table: "team_matches_match"
  team_matches_match(
    # distinct select on columns
    distinct_on: [team_matches_match_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_matches_match_order_by!]

    # filter the rows returned
    where: team_matches_match_bool_exp
  ): [team_matches_match!]!

  # fetch aggregated fields from the table: "team_matches_match"
  team_matches_match_aggregate(
    # distinct select on columns
    distinct_on: [team_matches_match_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_matches_match_order_by!]

    # filter the rows returned
    where: team_matches_match_bool_exp
  ): team_matches_match_aggregate!

  # fetch data from the table: "team_matches_match" using primary key columns
  team_matches_match_by_pk(matchId: Int!, teamId: Int!): team_matches_match

  # fetch data from the table: "team_players_player"
  team_players_player(
    # distinct select on columns
    distinct_on: [team_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_players_player_order_by!]

    # filter the rows returned
    where: team_players_player_bool_exp
  ): [team_players_player!]!

  # fetch aggregated fields from the table: "team_players_player"
  team_players_player_aggregate(
    # distinct select on columns
    distinct_on: [team_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_players_player_order_by!]

    # filter the rows returned
    where: team_players_player_bool_exp
  ): team_players_player_aggregate!

  # fetch data from the table: "team_players_player" using primary key columns
  team_players_player_by_pk(playerId: Int!, teamId: Int!): team_players_player

  # fetch data from the table: "user"
  user(
    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): [user!]!

  # fetch data from the table: "user" using primary key columns
  user_by_pk(id: Int!): user

  # fetch data from the table: "user_settings"
  user_settings(
    # distinct select on columns
    distinct_on: [user_settings_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_settings_order_by!]

    # filter the rows returned
    where: user_settings_bool_exp
  ): [user_settings!]!

  # fetch data from the table: "user_settings" using primary key columns
  user_settings_by_pk(id: Int!): user_settings

  # fetch data from the table: "utility_activated"
  utility_activated(
    # distinct select on columns
    distinct_on: [utility_activated_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_activated_order_by!]

    # filter the rows returned
    where: utility_activated_bool_exp
  ): [utility_activated!]!

  # fetch aggregated fields from the table: "utility_activated"
  utility_activated_aggregate(
    # distinct select on columns
    distinct_on: [utility_activated_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_activated_order_by!]

    # filter the rows returned
    where: utility_activated_bool_exp
  ): utility_activated_aggregate!

  # fetch data from the table: "utility_activated" using primary key columns
  utility_activated_by_pk(id: Int!): utility_activated

  # fetch data from the table: "utility_thrown"
  utility_thrown(
    # distinct select on columns
    distinct_on: [utility_thrown_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_thrown_order_by!]

    # filter the rows returned
    where: utility_thrown_bool_exp
  ): [utility_thrown!]!

  # fetch aggregated fields from the table: "utility_thrown"
  utility_thrown_aggregate(
    # distinct select on columns
    distinct_on: [utility_thrown_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_thrown_order_by!]

    # filter the rows returned
    where: utility_thrown_bool_exp
  ): utility_thrown_aggregate!

  # fetch data from the table: "utility_thrown" using primary key columns
  utility_thrown_by_pk(id: Int!): utility_thrown

  # fetch data from the table: "weapon_status"
  weapon_status(
    # distinct select on columns
    distinct_on: [weapon_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [weapon_status_order_by!]

    # filter the rows returned
    where: weapon_status_bool_exp
  ): [weapon_status!]!

  # fetch aggregated fields from the table: "weapon_status"
  weapon_status_aggregate(
    # distinct select on columns
    distinct_on: [weapon_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [weapon_status_order_by!]

    # filter the rows returned
    where: weapon_status_bool_exp
  ): weapon_status_aggregate!

  # fetch data from the table: "weapon_status" using primary key columns
  weapon_status_by_pk(id: Int!): weapon_status
}

# columns and relationships of "round"
type round {
  # An array relationship
  bomb_statuses(
    # distinct select on columns
    distinct_on: [bomb_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [bomb_status_order_by!]

    # filter the rows returned
    where: bomb_status_bool_exp
  ): [bomb_status!]!

  # An aggregated array relationship
  bomb_statuses_aggregate(
    # distinct select on columns
    distinct_on: [bomb_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [bomb_status_order_by!]

    # filter the rows returned
    where: bomb_status_bool_exp
  ): bomb_status_aggregate!
  createdAt: timestamp!
  endTick: Int!
  id: Int!

  # An array relationship
  kills(
    # distinct select on columns
    distinct_on: [kill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kill_order_by!]

    # filter the rows returned
    where: kill_bool_exp
  ): [kill!]!

  # An aggregated array relationship
  kills_aggregate(
    # distinct select on columns
    distinct_on: [kill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kill_order_by!]

    # filter the rows returned
    where: kill_bool_exp
  ): kill_aggregate!

  # An object relationship
  match: match
  matchId: Int
  officialEndTick: Int!

  # An array relationship
  player_blinds(
    # distinct select on columns
    distinct_on: [player_blind_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_blind_order_by!]

    # filter the rows returned
    where: player_blind_bool_exp
  ): [player_blind!]!

  # An aggregated array relationship
  player_blinds_aggregate(
    # distinct select on columns
    distinct_on: [player_blind_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_blind_order_by!]

    # filter the rows returned
    where: player_blind_bool_exp
  ): player_blind_aggregate!

  # An array relationship
  player_hurts(
    # distinct select on columns
    distinct_on: [player_hurt_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_hurt_order_by!]

    # filter the rows returned
    where: player_hurt_bool_exp
  ): [player_hurt!]!

  # An aggregated array relationship
  player_hurts_aggregate(
    # distinct select on columns
    distinct_on: [player_hurt_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_hurt_order_by!]

    # filter the rows returned
    where: player_hurt_bool_exp
  ): player_hurt_aggregate!

  # An array relationship
  player_jumps(
    # distinct select on columns
    distinct_on: [player_jump_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_jump_order_by!]

    # filter the rows returned
    where: player_jump_bool_exp
  ): [player_jump!]!

  # An aggregated array relationship
  player_jumps_aggregate(
    # distinct select on columns
    distinct_on: [player_jump_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_jump_order_by!]

    # filter the rows returned
    where: player_jump_bool_exp
  ): player_jump_aggregate!
  startTick: Int!

  # An array relationship
  teams(
    # distinct select on columns
    distinct_on: [team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_order_by!]

    # filter the rows returned
    where: team_bool_exp
  ): [team!]!

  # An aggregated array relationship
  teams_aggregate(
    # distinct select on columns
    distinct_on: [team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_order_by!]

    # filter the rows returned
    where: team_bool_exp
  ): team_aggregate!

  # An array relationship
  utility_activateds(
    # distinct select on columns
    distinct_on: [utility_activated_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_activated_order_by!]

    # filter the rows returned
    where: utility_activated_bool_exp
  ): [utility_activated!]!

  # An aggregated array relationship
  utility_activateds_aggregate(
    # distinct select on columns
    distinct_on: [utility_activated_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_activated_order_by!]

    # filter the rows returned
    where: utility_activated_bool_exp
  ): utility_activated_aggregate!

  # An array relationship
  utility_throwns(
    # distinct select on columns
    distinct_on: [utility_thrown_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_thrown_order_by!]

    # filter the rows returned
    where: utility_thrown_bool_exp
  ): [utility_thrown!]!

  # An aggregated array relationship
  utility_throwns_aggregate(
    # distinct select on columns
    distinct_on: [utility_thrown_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_thrown_order_by!]

    # filter the rows returned
    where: utility_thrown_bool_exp
  ): utility_thrown_aggregate!

  # An array relationship
  weapon_statuses(
    # distinct select on columns
    distinct_on: [weapon_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [weapon_status_order_by!]

    # filter the rows returned
    where: weapon_status_bool_exp
  ): [weapon_status!]!

  # An aggregated array relationship
  weapon_statuses_aggregate(
    # distinct select on columns
    distinct_on: [weapon_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [weapon_status_order_by!]

    # filter the rows returned
    where: weapon_status_bool_exp
  ): weapon_status_aggregate!
  winReason: Int!
}

# aggregated selection of "round"
type round_aggregate {
  aggregate: round_aggregate_fields
  nodes: [round!]!
}

# aggregate fields of "round"
type round_aggregate_fields {
  avg: round_avg_fields
  count(columns: [round_select_column!], distinct: Boolean): Int
  max: round_max_fields
  min: round_min_fields
  stddev: round_stddev_fields
  stddev_pop: round_stddev_pop_fields
  stddev_samp: round_stddev_samp_fields
  sum: round_sum_fields
  var_pop: round_var_pop_fields
  var_samp: round_var_samp_fields
  variance: round_variance_fields
}

# order by aggregate values of table "round"
input round_aggregate_order_by {
  avg: round_avg_order_by
  count: order_by
  max: round_max_order_by
  min: round_min_order_by
  stddev: round_stddev_order_by
  stddev_pop: round_stddev_pop_order_by
  stddev_samp: round_stddev_samp_order_by
  sum: round_sum_order_by
  var_pop: round_var_pop_order_by
  var_samp: round_var_samp_order_by
  variance: round_variance_order_by
}

# aggregate avg on columns
type round_avg_fields {
  endTick: Float
  id: Float
  matchId: Float
  officialEndTick: Float
  startTick: Float
  winReason: Float
}

# order by avg() on columns of table "round"
input round_avg_order_by {
  endTick: order_by
  id: order_by
  matchId: order_by
  officialEndTick: order_by
  startTick: order_by
  winReason: order_by
}

# Boolean expression to filter rows from the table "round". All fields are combined with a logical 'AND'.
input round_bool_exp {
  _and: [round_bool_exp]
  _not: round_bool_exp
  _or: [round_bool_exp]
  bomb_statuses: bomb_status_bool_exp
  createdAt: timestamp_comparison_exp
  endTick: Int_comparison_exp
  id: Int_comparison_exp
  kills: kill_bool_exp
  match: match_bool_exp
  matchId: Int_comparison_exp
  officialEndTick: Int_comparison_exp
  player_blinds: player_blind_bool_exp
  player_hurts: player_hurt_bool_exp
  player_jumps: player_jump_bool_exp
  startTick: Int_comparison_exp
  teams: team_bool_exp
  utility_activateds: utility_activated_bool_exp
  utility_throwns: utility_thrown_bool_exp
  weapon_statuses: weapon_status_bool_exp
  winReason: Int_comparison_exp
}

# aggregate max on columns
type round_max_fields {
  endTick: Int
  id: Int
  matchId: Int
  officialEndTick: Int
  startTick: Int
  winReason: Int
}

# order by max() on columns of table "round"
input round_max_order_by {
  endTick: order_by
  id: order_by
  matchId: order_by
  officialEndTick: order_by
  startTick: order_by
  winReason: order_by
}

# aggregate min on columns
type round_min_fields {
  endTick: Int
  id: Int
  matchId: Int
  officialEndTick: Int
  startTick: Int
  winReason: Int
}

# order by min() on columns of table "round"
input round_min_order_by {
  endTick: order_by
  id: order_by
  matchId: order_by
  officialEndTick: order_by
  startTick: order_by
  winReason: order_by
}

# ordering options when selecting data from "round"
input round_order_by {
  bomb_statuses_aggregate: bomb_status_aggregate_order_by
  createdAt: order_by
  endTick: order_by
  id: order_by
  kills_aggregate: kill_aggregate_order_by
  match: match_order_by
  matchId: order_by
  officialEndTick: order_by
  player_blinds_aggregate: player_blind_aggregate_order_by
  player_hurts_aggregate: player_hurt_aggregate_order_by
  player_jumps_aggregate: player_jump_aggregate_order_by
  startTick: order_by
  teams_aggregate: team_aggregate_order_by
  utility_activateds_aggregate: utility_activated_aggregate_order_by
  utility_throwns_aggregate: utility_thrown_aggregate_order_by
  weapon_statuses_aggregate: weapon_status_aggregate_order_by
  winReason: order_by
}

# select columns of table "round"
enum round_select_column {
  # column name
  createdAt

  # column name
  endTick

  # column name
  id

  # column name
  matchId

  # column name
  officialEndTick

  # column name
  startTick

  # column name
  winReason
}

# aggregate stddev on columns
type round_stddev_fields {
  endTick: Float
  id: Float
  matchId: Float
  officialEndTick: Float
  startTick: Float
  winReason: Float
}

# order by stddev() on columns of table "round"
input round_stddev_order_by {
  endTick: order_by
  id: order_by
  matchId: order_by
  officialEndTick: order_by
  startTick: order_by
  winReason: order_by
}

# aggregate stddev_pop on columns
type round_stddev_pop_fields {
  endTick: Float
  id: Float
  matchId: Float
  officialEndTick: Float
  startTick: Float
  winReason: Float
}

# order by stddev_pop() on columns of table "round"
input round_stddev_pop_order_by {
  endTick: order_by
  id: order_by
  matchId: order_by
  officialEndTick: order_by
  startTick: order_by
  winReason: order_by
}

# aggregate stddev_samp on columns
type round_stddev_samp_fields {
  endTick: Float
  id: Float
  matchId: Float
  officialEndTick: Float
  startTick: Float
  winReason: Float
}

# order by stddev_samp() on columns of table "round"
input round_stddev_samp_order_by {
  endTick: order_by
  id: order_by
  matchId: order_by
  officialEndTick: order_by
  startTick: order_by
  winReason: order_by
}

# aggregate sum on columns
type round_sum_fields {
  endTick: Int
  id: Int
  matchId: Int
  officialEndTick: Int
  startTick: Int
  winReason: Int
}

# order by sum() on columns of table "round"
input round_sum_order_by {
  endTick: order_by
  id: order_by
  matchId: order_by
  officialEndTick: order_by
  startTick: order_by
  winReason: order_by
}

# aggregate var_pop on columns
type round_var_pop_fields {
  endTick: Float
  id: Float
  matchId: Float
  officialEndTick: Float
  startTick: Float
  winReason: Float
}

# order by var_pop() on columns of table "round"
input round_var_pop_order_by {
  endTick: order_by
  id: order_by
  matchId: order_by
  officialEndTick: order_by
  startTick: order_by
  winReason: order_by
}

# aggregate var_samp on columns
type round_var_samp_fields {
  endTick: Float
  id: Float
  matchId: Float
  officialEndTick: Float
  startTick: Float
  winReason: Float
}

# order by var_samp() on columns of table "round"
input round_var_samp_order_by {
  endTick: order_by
  id: order_by
  matchId: order_by
  officialEndTick: order_by
  startTick: order_by
  winReason: order_by
}

# aggregate variance on columns
type round_variance_fields {
  endTick: Float
  id: Float
  matchId: Float
  officialEndTick: Float
  startTick: Float
  winReason: Float
}

# order by variance() on columns of table "round"
input round_variance_order_by {
  endTick: order_by
  id: order_by
  matchId: order_by
  officialEndTick: order_by
  startTick: order_by
  winReason: order_by
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "ban"
  ban(
    # distinct select on columns
    distinct_on: [ban_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [ban_order_by!]

    # filter the rows returned
    where: ban_bool_exp
  ): [ban!]!

  # fetch aggregated fields from the table: "ban"
  ban_aggregate(
    # distinct select on columns
    distinct_on: [ban_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [ban_order_by!]

    # filter the rows returned
    where: ban_bool_exp
  ): ban_aggregate!

  # fetch data from the table: "ban" using primary key columns
  ban_by_pk(id: Int!): ban

  # fetch data from the table: "bomb_status"
  bomb_status(
    # distinct select on columns
    distinct_on: [bomb_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [bomb_status_order_by!]

    # filter the rows returned
    where: bomb_status_bool_exp
  ): [bomb_status!]!

  # fetch aggregated fields from the table: "bomb_status"
  bomb_status_aggregate(
    # distinct select on columns
    distinct_on: [bomb_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [bomb_status_order_by!]

    # filter the rows returned
    where: bomb_status_bool_exp
  ): bomb_status_aggregate!

  # fetch data from the table: "bomb_status" using primary key columns
  bomb_status_by_pk(id: Int!): bomb_status

  # fetch data from the table: "kill"
  kill(
    # distinct select on columns
    distinct_on: [kill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kill_order_by!]

    # filter the rows returned
    where: kill_bool_exp
  ): [kill!]!

  # fetch aggregated fields from the table: "kill"
  kill_aggregate(
    # distinct select on columns
    distinct_on: [kill_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kill_order_by!]

    # filter the rows returned
    where: kill_bool_exp
  ): kill_aggregate!

  # fetch data from the table: "kill" using primary key columns
  kill_by_pk(id: Int!): kill

  # fetch data from the table: "match"
  match(
    # distinct select on columns
    distinct_on: [match_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_order_by!]

    # filter the rows returned
    where: match_bool_exp
  ): [match!]!

  # fetch aggregated fields from the table: "match"
  match_aggregate(
    # distinct select on columns
    distinct_on: [match_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_order_by!]

    # filter the rows returned
    where: match_bool_exp
  ): match_aggregate!

  # fetch data from the table: "match" using primary key columns
  match_by_pk(id: Int!): match

  # fetch data from the table: "match_players_player"
  match_players_player(
    # distinct select on columns
    distinct_on: [match_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_players_player_order_by!]

    # filter the rows returned
    where: match_players_player_bool_exp
  ): [match_players_player!]!

  # fetch aggregated fields from the table: "match_players_player"
  match_players_player_aggregate(
    # distinct select on columns
    distinct_on: [match_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_players_player_order_by!]

    # filter the rows returned
    where: match_players_player_bool_exp
  ): match_players_player_aggregate!

  # fetch data from the table: "match_players_player" using primary key columns
  match_players_player_by_pk(matchId: Int!, playerId: Int!): match_players_player

  # fetch data from the table: "match_teams_team"
  match_teams_team(
    # distinct select on columns
    distinct_on: [match_teams_team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_teams_team_order_by!]

    # filter the rows returned
    where: match_teams_team_bool_exp
  ): [match_teams_team!]!

  # fetch aggregated fields from the table: "match_teams_team"
  match_teams_team_aggregate(
    # distinct select on columns
    distinct_on: [match_teams_team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_teams_team_order_by!]

    # filter the rows returned
    where: match_teams_team_bool_exp
  ): match_teams_team_aggregate!

  # fetch data from the table: "match_teams_team" using primary key columns
  match_teams_team_by_pk(matchId: Int!, teamId: Int!): match_teams_team

  # fetch data from the table: "notification"
  notification(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): [notification!]!

  # fetch aggregated fields from the table: "notification"
  notification_aggregate(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): notification_aggregate!

  # fetch data from the table: "notification_bans_ban"
  notification_bans_ban(
    # distinct select on columns
    distinct_on: [notification_bans_ban_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_bans_ban_order_by!]

    # filter the rows returned
    where: notification_bans_ban_bool_exp
  ): [notification_bans_ban!]!

  # fetch aggregated fields from the table: "notification_bans_ban"
  notification_bans_ban_aggregate(
    # distinct select on columns
    distinct_on: [notification_bans_ban_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_bans_ban_order_by!]

    # filter the rows returned
    where: notification_bans_ban_bool_exp
  ): notification_bans_ban_aggregate!

  # fetch data from the table: "notification_bans_ban" using primary key columns
  notification_bans_ban_by_pk(banId: Int!, notificationId: Int!): notification_bans_ban

  # fetch data from the table: "notification" using primary key columns
  notification_by_pk(id: Int!): notification

  # fetch data from the table: "player"
  player(
    # distinct select on columns
    distinct_on: [player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_order_by!]

    # filter the rows returned
    where: player_bool_exp
  ): [player!]!

  # fetch aggregated fields from the table: "player"
  player_aggregate(
    # distinct select on columns
    distinct_on: [player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_order_by!]

    # filter the rows returned
    where: player_bool_exp
  ): player_aggregate!

  # fetch data from the table: "player_blind"
  player_blind(
    # distinct select on columns
    distinct_on: [player_blind_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_blind_order_by!]

    # filter the rows returned
    where: player_blind_bool_exp
  ): [player_blind!]!

  # fetch aggregated fields from the table: "player_blind"
  player_blind_aggregate(
    # distinct select on columns
    distinct_on: [player_blind_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_blind_order_by!]

    # filter the rows returned
    where: player_blind_bool_exp
  ): player_blind_aggregate!

  # fetch data from the table: "player_blind" using primary key columns
  player_blind_by_pk(id: Int!): player_blind

  # fetch data from the table: "player" using primary key columns
  player_by_pk(id: Int!): player

  # fetch data from the table: "player_followed_by_user"
  player_followed_by_user(
    # distinct select on columns
    distinct_on: [player_followed_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_followed_by_user_order_by!]

    # filter the rows returned
    where: player_followed_by_user_bool_exp
  ): [player_followed_by_user!]!

  # fetch aggregated fields from the table: "player_followed_by_user"
  player_followed_by_user_aggregate(
    # distinct select on columns
    distinct_on: [player_followed_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_followed_by_user_order_by!]

    # filter the rows returned
    where: player_followed_by_user_bool_exp
  ): player_followed_by_user_aggregate!

  # fetch data from the table: "player_followed_by_user" using primary key columns
  player_followed_by_user_by_pk(playerId: Int!, userId: Int!): player_followed_by_user

  # fetch data from the table: "player_hurt"
  player_hurt(
    # distinct select on columns
    distinct_on: [player_hurt_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_hurt_order_by!]

    # filter the rows returned
    where: player_hurt_bool_exp
  ): [player_hurt!]!

  # fetch aggregated fields from the table: "player_hurt"
  player_hurt_aggregate(
    # distinct select on columns
    distinct_on: [player_hurt_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_hurt_order_by!]

    # filter the rows returned
    where: player_hurt_bool_exp
  ): player_hurt_aggregate!

  # fetch data from the table: "player_hurt" using primary key columns
  player_hurt_by_pk(id: Int!): player_hurt

  # fetch data from the table: "player_info"
  player_info(
    # distinct select on columns
    distinct_on: [player_info_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_info_order_by!]

    # filter the rows returned
    where: player_info_bool_exp
  ): [player_info!]!

  # fetch aggregated fields from the table: "player_info"
  player_info_aggregate(
    # distinct select on columns
    distinct_on: [player_info_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_info_order_by!]

    # filter the rows returned
    where: player_info_bool_exp
  ): player_info_aggregate!

  # fetch data from the table: "player_info" using primary key columns
  player_info_by_pk(id: Int!): player_info

  # fetch data from the table: "player_jump"
  player_jump(
    # distinct select on columns
    distinct_on: [player_jump_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_jump_order_by!]

    # filter the rows returned
    where: player_jump_bool_exp
  ): [player_jump!]!

  # fetch aggregated fields from the table: "player_jump"
  player_jump_aggregate(
    # distinct select on columns
    distinct_on: [player_jump_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_jump_order_by!]

    # filter the rows returned
    where: player_jump_bool_exp
  ): player_jump_aggregate!

  # fetch data from the table: "player_jump" using primary key columns
  player_jump_by_pk(id: Int!): player_jump

  # fetch data from the table: "player_tracked_by_user"
  player_tracked_by_user(
    # distinct select on columns
    distinct_on: [player_tracked_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_tracked_by_user_order_by!]

    # filter the rows returned
    where: player_tracked_by_user_bool_exp
  ): [player_tracked_by_user!]!

  # fetch aggregated fields from the table: "player_tracked_by_user"
  player_tracked_by_user_aggregate(
    # distinct select on columns
    distinct_on: [player_tracked_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_tracked_by_user_order_by!]

    # filter the rows returned
    where: player_tracked_by_user_bool_exp
  ): player_tracked_by_user_aggregate!

  # fetch data from the table: "player_tracked_by_user" using primary key columns
  player_tracked_by_user_by_pk(playerId: Int!, userId: Int!): player_tracked_by_user

  # fetch data from the table: "position"
  position(
    # distinct select on columns
    distinct_on: [position_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [position_order_by!]

    # filter the rows returned
    where: position_bool_exp
  ): [position!]!

  # fetch aggregated fields from the table: "position"
  position_aggregate(
    # distinct select on columns
    distinct_on: [position_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [position_order_by!]

    # filter the rows returned
    where: position_bool_exp
  ): position_aggregate!

  # fetch data from the table: "position" using primary key columns
  position_by_pk(id: Int!): position

  # fetch data from the table: "round"
  round(
    # distinct select on columns
    distinct_on: [round_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [round_order_by!]

    # filter the rows returned
    where: round_bool_exp
  ): [round!]!

  # fetch aggregated fields from the table: "round"
  round_aggregate(
    # distinct select on columns
    distinct_on: [round_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [round_order_by!]

    # filter the rows returned
    where: round_bool_exp
  ): round_aggregate!

  # fetch data from the table: "round" using primary key columns
  round_by_pk(id: Int!): round

  # fetch data from the table: "team"
  team(
    # distinct select on columns
    distinct_on: [team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_order_by!]

    # filter the rows returned
    where: team_bool_exp
  ): [team!]!

  # fetch aggregated fields from the table: "team"
  team_aggregate(
    # distinct select on columns
    distinct_on: [team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_order_by!]

    # filter the rows returned
    where: team_bool_exp
  ): team_aggregate!

  # fetch data from the table: "team" using primary key columns
  team_by_pk(id: Int!): team

  # fetch data from the table: "team_matches_match"
  team_matches_match(
    # distinct select on columns
    distinct_on: [team_matches_match_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_matches_match_order_by!]

    # filter the rows returned
    where: team_matches_match_bool_exp
  ): [team_matches_match!]!

  # fetch aggregated fields from the table: "team_matches_match"
  team_matches_match_aggregate(
    # distinct select on columns
    distinct_on: [team_matches_match_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_matches_match_order_by!]

    # filter the rows returned
    where: team_matches_match_bool_exp
  ): team_matches_match_aggregate!

  # fetch data from the table: "team_matches_match" using primary key columns
  team_matches_match_by_pk(matchId: Int!, teamId: Int!): team_matches_match

  # fetch data from the table: "team_players_player"
  team_players_player(
    # distinct select on columns
    distinct_on: [team_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_players_player_order_by!]

    # filter the rows returned
    where: team_players_player_bool_exp
  ): [team_players_player!]!

  # fetch aggregated fields from the table: "team_players_player"
  team_players_player_aggregate(
    # distinct select on columns
    distinct_on: [team_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_players_player_order_by!]

    # filter the rows returned
    where: team_players_player_bool_exp
  ): team_players_player_aggregate!

  # fetch data from the table: "team_players_player" using primary key columns
  team_players_player_by_pk(playerId: Int!, teamId: Int!): team_players_player

  # fetch data from the table: "user"
  user(
    # distinct select on columns
    distinct_on: [user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_order_by!]

    # filter the rows returned
    where: user_bool_exp
  ): [user!]!

  # fetch data from the table: "user" using primary key columns
  user_by_pk(id: Int!): user

  # fetch data from the table: "user_settings"
  user_settings(
    # distinct select on columns
    distinct_on: [user_settings_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_settings_order_by!]

    # filter the rows returned
    where: user_settings_bool_exp
  ): [user_settings!]!

  # fetch data from the table: "user_settings" using primary key columns
  user_settings_by_pk(id: Int!): user_settings

  # fetch data from the table: "utility_activated"
  utility_activated(
    # distinct select on columns
    distinct_on: [utility_activated_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_activated_order_by!]

    # filter the rows returned
    where: utility_activated_bool_exp
  ): [utility_activated!]!

  # fetch aggregated fields from the table: "utility_activated"
  utility_activated_aggregate(
    # distinct select on columns
    distinct_on: [utility_activated_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_activated_order_by!]

    # filter the rows returned
    where: utility_activated_bool_exp
  ): utility_activated_aggregate!

  # fetch data from the table: "utility_activated" using primary key columns
  utility_activated_by_pk(id: Int!): utility_activated

  # fetch data from the table: "utility_thrown"
  utility_thrown(
    # distinct select on columns
    distinct_on: [utility_thrown_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_thrown_order_by!]

    # filter the rows returned
    where: utility_thrown_bool_exp
  ): [utility_thrown!]!

  # fetch aggregated fields from the table: "utility_thrown"
  utility_thrown_aggregate(
    # distinct select on columns
    distinct_on: [utility_thrown_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [utility_thrown_order_by!]

    # filter the rows returned
    where: utility_thrown_bool_exp
  ): utility_thrown_aggregate!

  # fetch data from the table: "utility_thrown" using primary key columns
  utility_thrown_by_pk(id: Int!): utility_thrown

  # fetch data from the table: "weapon_status"
  weapon_status(
    # distinct select on columns
    distinct_on: [weapon_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [weapon_status_order_by!]

    # filter the rows returned
    where: weapon_status_bool_exp
  ): [weapon_status!]!

  # fetch aggregated fields from the table: "weapon_status"
  weapon_status_aggregate(
    # distinct select on columns
    distinct_on: [weapon_status_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [weapon_status_order_by!]

    # filter the rows returned
    where: weapon_status_bool_exp
  ): weapon_status_aggregate!

  # fetch data from the table: "weapon_status" using primary key columns
  weapon_status_by_pk(id: Int!): weapon_status
}

# columns and relationships of "team"
type team {
  createdAt: timestamp!
  id: Int!

  # An array relationship
  matches(
    # distinct select on columns
    distinct_on: [match_teams_team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_teams_team_order_by!]

    # filter the rows returned
    where: match_teams_team_bool_exp
  ): [match_teams_team!]!

  # An aggregated array relationship
  matches_aggregate(
    # distinct select on columns
    distinct_on: [match_teams_team_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [match_teams_team_order_by!]

    # filter the rows returned
    where: match_teams_team_bool_exp
  ): match_teams_team_aggregate!
  name: String

  # An array relationship
  players(
    # distinct select on columns
    distinct_on: [team_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_players_player_order_by!]

    # filter the rows returned
    where: team_players_player_bool_exp
  ): [team_players_player!]!

  # An aggregated array relationship
  players_aggregate(
    # distinct select on columns
    distinct_on: [team_players_player_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [team_players_player_order_by!]

    # filter the rows returned
    where: team_players_player_bool_exp
  ): team_players_player_aggregate!

  # An object relationship
  round: round
  roundsWonId: Int
}

# aggregated selection of "team"
type team_aggregate {
  aggregate: team_aggregate_fields
  nodes: [team!]!
}

# aggregate fields of "team"
type team_aggregate_fields {
  avg: team_avg_fields
  count(columns: [team_select_column!], distinct: Boolean): Int
  max: team_max_fields
  min: team_min_fields
  stddev: team_stddev_fields
  stddev_pop: team_stddev_pop_fields
  stddev_samp: team_stddev_samp_fields
  sum: team_sum_fields
  var_pop: team_var_pop_fields
  var_samp: team_var_samp_fields
  variance: team_variance_fields
}

# order by aggregate values of table "team"
input team_aggregate_order_by {
  avg: team_avg_order_by
  count: order_by
  max: team_max_order_by
  min: team_min_order_by
  stddev: team_stddev_order_by
  stddev_pop: team_stddev_pop_order_by
  stddev_samp: team_stddev_samp_order_by
  sum: team_sum_order_by
  var_pop: team_var_pop_order_by
  var_samp: team_var_samp_order_by
  variance: team_variance_order_by
}

# aggregate avg on columns
type team_avg_fields {
  id: Float
  roundsWonId: Float
}

# order by avg() on columns of table "team"
input team_avg_order_by {
  id: order_by
  roundsWonId: order_by
}

# Boolean expression to filter rows from the table "team". All fields are combined with a logical 'AND'.
input team_bool_exp {
  _and: [team_bool_exp]
  _not: team_bool_exp
  _or: [team_bool_exp]
  createdAt: timestamp_comparison_exp
  id: Int_comparison_exp
  matches: match_teams_team_bool_exp
  name: String_comparison_exp
  players: team_players_player_bool_exp
  round: round_bool_exp
  roundsWonId: Int_comparison_exp
}

# columns and relationships of "team_matches_match"
type team_matches_match {
  # An object relationship
  match: match!
  matchId: Int!

  # An object relationship
  team: team!
  teamId: Int!
}

# aggregated selection of "team_matches_match"
type team_matches_match_aggregate {
  aggregate: team_matches_match_aggregate_fields
  nodes: [team_matches_match!]!
}

# aggregate fields of "team_matches_match"
type team_matches_match_aggregate_fields {
  avg: team_matches_match_avg_fields
  count(columns: [team_matches_match_select_column!], distinct: Boolean): Int
  max: team_matches_match_max_fields
  min: team_matches_match_min_fields
  stddev: team_matches_match_stddev_fields
  stddev_pop: team_matches_match_stddev_pop_fields
  stddev_samp: team_matches_match_stddev_samp_fields
  sum: team_matches_match_sum_fields
  var_pop: team_matches_match_var_pop_fields
  var_samp: team_matches_match_var_samp_fields
  variance: team_matches_match_variance_fields
}

# order by aggregate values of table "team_matches_match"
input team_matches_match_aggregate_order_by {
  avg: team_matches_match_avg_order_by
  count: order_by
  max: team_matches_match_max_order_by
  min: team_matches_match_min_order_by
  stddev: team_matches_match_stddev_order_by
  stddev_pop: team_matches_match_stddev_pop_order_by
  stddev_samp: team_matches_match_stddev_samp_order_by
  sum: team_matches_match_sum_order_by
  var_pop: team_matches_match_var_pop_order_by
  var_samp: team_matches_match_var_samp_order_by
  variance: team_matches_match_variance_order_by
}

# aggregate avg on columns
type team_matches_match_avg_fields {
  matchId: Float
  teamId: Float
}

# order by avg() on columns of table "team_matches_match"
input team_matches_match_avg_order_by {
  matchId: order_by
  teamId: order_by
}

# Boolean expression to filter rows from the table "team_matches_match". All fields are combined with a logical 'AND'.
input team_matches_match_bool_exp {
  _and: [team_matches_match_bool_exp]
  _not: team_matches_match_bool_exp
  _or: [team_matches_match_bool_exp]
  match: match_bool_exp
  matchId: Int_comparison_exp
  team: team_bool_exp
  teamId: Int_comparison_exp
}

# aggregate max on columns
type team_matches_match_max_fields {
  matchId: Int
  teamId: Int
}

# order by max() on columns of table "team_matches_match"
input team_matches_match_max_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate min on columns
type team_matches_match_min_fields {
  matchId: Int
  teamId: Int
}

# order by min() on columns of table "team_matches_match"
input team_matches_match_min_order_by {
  matchId: order_by
  teamId: order_by
}

# ordering options when selecting data from "team_matches_match"
input team_matches_match_order_by {
  match: match_order_by
  matchId: order_by
  team: team_order_by
  teamId: order_by
}

# select columns of table "team_matches_match"
enum team_matches_match_select_column {
  # column name
  matchId

  # column name
  teamId
}

# aggregate stddev on columns
type team_matches_match_stddev_fields {
  matchId: Float
  teamId: Float
}

# order by stddev() on columns of table "team_matches_match"
input team_matches_match_stddev_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate stddev_pop on columns
type team_matches_match_stddev_pop_fields {
  matchId: Float
  teamId: Float
}

# order by stddev_pop() on columns of table "team_matches_match"
input team_matches_match_stddev_pop_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate stddev_samp on columns
type team_matches_match_stddev_samp_fields {
  matchId: Float
  teamId: Float
}

# order by stddev_samp() on columns of table "team_matches_match"
input team_matches_match_stddev_samp_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate sum on columns
type team_matches_match_sum_fields {
  matchId: Int
  teamId: Int
}

# order by sum() on columns of table "team_matches_match"
input team_matches_match_sum_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate var_pop on columns
type team_matches_match_var_pop_fields {
  matchId: Float
  teamId: Float
}

# order by var_pop() on columns of table "team_matches_match"
input team_matches_match_var_pop_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate var_samp on columns
type team_matches_match_var_samp_fields {
  matchId: Float
  teamId: Float
}

# order by var_samp() on columns of table "team_matches_match"
input team_matches_match_var_samp_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate variance on columns
type team_matches_match_variance_fields {
  matchId: Float
  teamId: Float
}

# order by variance() on columns of table "team_matches_match"
input team_matches_match_variance_order_by {
  matchId: order_by
  teamId: order_by
}

# aggregate max on columns
type team_max_fields {
  id: Int
  name: String
  roundsWonId: Int
}

# order by max() on columns of table "team"
input team_max_order_by {
  id: order_by
  name: order_by
  roundsWonId: order_by
}

# aggregate min on columns
type team_min_fields {
  id: Int
  name: String
  roundsWonId: Int
}

# order by min() on columns of table "team"
input team_min_order_by {
  id: order_by
  name: order_by
  roundsWonId: order_by
}

# ordering options when selecting data from "team"
input team_order_by {
  createdAt: order_by
  id: order_by
  matches_aggregate: match_teams_team_aggregate_order_by
  name: order_by
  players_aggregate: team_players_player_aggregate_order_by
  round: round_order_by
  roundsWonId: order_by
}

# columns and relationships of "team_players_player"
type team_players_player {
  # An object relationship
  player: player!
  playerId: Int!

  # An object relationship
  team: team!
  teamId: Int!
}

# aggregated selection of "team_players_player"
type team_players_player_aggregate {
  aggregate: team_players_player_aggregate_fields
  nodes: [team_players_player!]!
}

# aggregate fields of "team_players_player"
type team_players_player_aggregate_fields {
  avg: team_players_player_avg_fields
  count(columns: [team_players_player_select_column!], distinct: Boolean): Int
  max: team_players_player_max_fields
  min: team_players_player_min_fields
  stddev: team_players_player_stddev_fields
  stddev_pop: team_players_player_stddev_pop_fields
  stddev_samp: team_players_player_stddev_samp_fields
  sum: team_players_player_sum_fields
  var_pop: team_players_player_var_pop_fields
  var_samp: team_players_player_var_samp_fields
  variance: team_players_player_variance_fields
}

# order by aggregate values of table "team_players_player"
input team_players_player_aggregate_order_by {
  avg: team_players_player_avg_order_by
  count: order_by
  max: team_players_player_max_order_by
  min: team_players_player_min_order_by
  stddev: team_players_player_stddev_order_by
  stddev_pop: team_players_player_stddev_pop_order_by
  stddev_samp: team_players_player_stddev_samp_order_by
  sum: team_players_player_sum_order_by
  var_pop: team_players_player_var_pop_order_by
  var_samp: team_players_player_var_samp_order_by
  variance: team_players_player_variance_order_by
}

# aggregate avg on columns
type team_players_player_avg_fields {
  playerId: Float
  teamId: Float
}

# order by avg() on columns of table "team_players_player"
input team_players_player_avg_order_by {
  playerId: order_by
  teamId: order_by
}

# Boolean expression to filter rows from the table "team_players_player". All fields are combined with a logical 'AND'.
input team_players_player_bool_exp {
  _and: [team_players_player_bool_exp]
  _not: team_players_player_bool_exp
  _or: [team_players_player_bool_exp]
  player: player_bool_exp
  playerId: Int_comparison_exp
  team: team_bool_exp
  teamId: Int_comparison_exp
}

# aggregate max on columns
type team_players_player_max_fields {
  playerId: Int
  teamId: Int
}

# order by max() on columns of table "team_players_player"
input team_players_player_max_order_by {
  playerId: order_by
  teamId: order_by
}

# aggregate min on columns
type team_players_player_min_fields {
  playerId: Int
  teamId: Int
}

# order by min() on columns of table "team_players_player"
input team_players_player_min_order_by {
  playerId: order_by
  teamId: order_by
}

# ordering options when selecting data from "team_players_player"
input team_players_player_order_by {
  player: player_order_by
  playerId: order_by
  team: team_order_by
  teamId: order_by
}

# select columns of table "team_players_player"
enum team_players_player_select_column {
  # column name
  playerId

  # column name
  teamId
}

# aggregate stddev on columns
type team_players_player_stddev_fields {
  playerId: Float
  teamId: Float
}

# order by stddev() on columns of table "team_players_player"
input team_players_player_stddev_order_by {
  playerId: order_by
  teamId: order_by
}

# aggregate stddev_pop on columns
type team_players_player_stddev_pop_fields {
  playerId: Float
  teamId: Float
}

# order by stddev_pop() on columns of table "team_players_player"
input team_players_player_stddev_pop_order_by {
  playerId: order_by
  teamId: order_by
}

# aggregate stddev_samp on columns
type team_players_player_stddev_samp_fields {
  playerId: Float
  teamId: Float
}

# order by stddev_samp() on columns of table "team_players_player"
input team_players_player_stddev_samp_order_by {
  playerId: order_by
  teamId: order_by
}

# aggregate sum on columns
type team_players_player_sum_fields {
  playerId: Int
  teamId: Int
}

# order by sum() on columns of table "team_players_player"
input team_players_player_sum_order_by {
  playerId: order_by
  teamId: order_by
}

# aggregate var_pop on columns
type team_players_player_var_pop_fields {
  playerId: Float
  teamId: Float
}

# order by var_pop() on columns of table "team_players_player"
input team_players_player_var_pop_order_by {
  playerId: order_by
  teamId: order_by
}

# aggregate var_samp on columns
type team_players_player_var_samp_fields {
  playerId: Float
  teamId: Float
}

# order by var_samp() on columns of table "team_players_player"
input team_players_player_var_samp_order_by {
  playerId: order_by
  teamId: order_by
}

# aggregate variance on columns
type team_players_player_variance_fields {
  playerId: Float
  teamId: Float
}

# order by variance() on columns of table "team_players_player"
input team_players_player_variance_order_by {
  playerId: order_by
  teamId: order_by
}

# select columns of table "team"
enum team_select_column {
  # column name
  createdAt

  # column name
  id

  # column name
  name

  # column name
  roundsWonId
}

# aggregate stddev on columns
type team_stddev_fields {
  id: Float
  roundsWonId: Float
}

# order by stddev() on columns of table "team"
input team_stddev_order_by {
  id: order_by
  roundsWonId: order_by
}

# aggregate stddev_pop on columns
type team_stddev_pop_fields {
  id: Float
  roundsWonId: Float
}

# order by stddev_pop() on columns of table "team"
input team_stddev_pop_order_by {
  id: order_by
  roundsWonId: order_by
}

# aggregate stddev_samp on columns
type team_stddev_samp_fields {
  id: Float
  roundsWonId: Float
}

# order by stddev_samp() on columns of table "team"
input team_stddev_samp_order_by {
  id: order_by
  roundsWonId: order_by
}

# aggregate sum on columns
type team_sum_fields {
  id: Int
  roundsWonId: Int
}

# order by sum() on columns of table "team"
input team_sum_order_by {
  id: order_by
  roundsWonId: order_by
}

# aggregate var_pop on columns
type team_var_pop_fields {
  id: Float
  roundsWonId: Float
}

# order by var_pop() on columns of table "team"
input team_var_pop_order_by {
  id: order_by
  roundsWonId: order_by
}

# aggregate var_samp on columns
type team_var_samp_fields {
  id: Float
  roundsWonId: Float
}

# order by var_samp() on columns of table "team"
input team_var_samp_order_by {
  id: order_by
  roundsWonId: order_by
}

# aggregate variance on columns
type team_variance_fields {
  id: Float
  roundsWonId: Float
}

# order by variance() on columns of table "team"
input team_variance_order_by {
  id: order_by
  roundsWonId: order_by
}

scalar timestamp

# expression to compare columns of type timestamp. All fields are combined with logical 'AND'.
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

# columns and relationships of "user"
type user {
  discordId: String
  faceitId: String
  faceitName: String

  # An array relationship
  follows(
    # distinct select on columns
    distinct_on: [player_followed_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_followed_by_user_order_by!]

    # filter the rows returned
    where: player_followed_by_user_bool_exp
  ): [player_followed_by_user!]!

  # An aggregated array relationship
  follows_aggregate(
    # distinct select on columns
    distinct_on: [player_followed_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_followed_by_user_order_by!]

    # filter the rows returned
    where: player_followed_by_user_bool_exp
  ): player_followed_by_user_aggregate!
  id: Int!
  lastCheckedAtFaceit: timestamp!
  lastCheckedAtSteam: timestamp!

  # An array relationship
  notifications(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): [notification!]!

  # An aggregated array relationship
  notifications_aggregate(
    # distinct select on columns
    distinct_on: [notification_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notification_order_by!]

    # filter the rows returned
    where: notification_bool_exp
  ): notification_aggregate!
  role: String!

  # An object relationship
  settings: user_settings
  settingsId: Int
  steamId: String!

  # An array relationship
  tracks(
    # distinct select on columns
    distinct_on: [player_tracked_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_tracked_by_user_order_by!]

    # filter the rows returned
    where: player_tracked_by_user_bool_exp
  ): [player_tracked_by_user!]!

  # An aggregated array relationship
  tracks_aggregate(
    # distinct select on columns
    distinct_on: [player_tracked_by_user_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [player_tracked_by_user_order_by!]

    # filter the rows returned
    where: player_tracked_by_user_bool_exp
  ): player_tracked_by_user_aggregate!
  username: String!
}

# Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
input user_bool_exp {
  _and: [user_bool_exp]
  _not: user_bool_exp
  _or: [user_bool_exp]
  discordId: String_comparison_exp
  faceitId: String_comparison_exp
  faceitName: String_comparison_exp
  follows: player_followed_by_user_bool_exp
  id: Int_comparison_exp
  lastCheckedAtFaceit: timestamp_comparison_exp
  lastCheckedAtSteam: timestamp_comparison_exp
  notifications: notification_bool_exp
  role: String_comparison_exp
  settings: user_settings_bool_exp
  settingsId: Int_comparison_exp
  steamId: String_comparison_exp
  tracks: player_tracked_by_user_bool_exp
  username: String_comparison_exp
}

# ordering options when selecting data from "user"
input user_order_by {
  discordId: order_by
  faceitId: order_by
  faceitName: order_by
  follows_aggregate: player_followed_by_user_aggregate_order_by
  id: order_by
  lastCheckedAtFaceit: order_by
  lastCheckedAtSteam: order_by
  notifications_aggregate: notification_aggregate_order_by
  role: order_by
  settings: user_settings_order_by
  settingsId: order_by
  steamId: order_by
  tracks_aggregate: player_tracked_by_user_aggregate_order_by
  username: order_by
}

# select columns of table "user"
enum user_select_column {
  # column name
  discordId

  # column name
  faceitId

  # column name
  faceitName

  # column name
  id

  # column name
  lastCheckedAtFaceit

  # column name
  lastCheckedAtSteam

  # column name
  role

  # column name
  settingsId

  # column name
  steamId

  # column name
  username
}

# columns and relationships of "user_settings"
type user_settings {
  lastKnownMatch: String
  matchAuthCode: String
  notificationCommunityEnabled: Boolean!
  notificationDiscordEnabled: Boolean!
  notificationEconomyEnabled: Boolean!
  notificationFaceitEnabled: Boolean!
  notificationGameEnabled: Boolean!
  notificationVACEnabled: Boolean!

  # An object relationship
  user: user
}

# Boolean expression to filter rows from the table "user_settings". All fields are combined with a logical 'AND'.
input user_settings_bool_exp {
  _and: [user_settings_bool_exp]
  _not: user_settings_bool_exp
  _or: [user_settings_bool_exp]
  lastKnownMatch: String_comparison_exp
  matchAuthCode: String_comparison_exp
  notificationCommunityEnabled: Boolean_comparison_exp
  notificationDiscordEnabled: Boolean_comparison_exp
  notificationEconomyEnabled: Boolean_comparison_exp
  notificationFaceitEnabled: Boolean_comparison_exp
  notificationGameEnabled: Boolean_comparison_exp
  notificationVACEnabled: Boolean_comparison_exp
  user: user_bool_exp
}

# ordering options when selecting data from "user_settings"
input user_settings_order_by {
  lastKnownMatch: order_by
  matchAuthCode: order_by
  notificationCommunityEnabled: order_by
  notificationDiscordEnabled: order_by
  notificationEconomyEnabled: order_by
  notificationFaceitEnabled: order_by
  notificationGameEnabled: order_by
  notificationVACEnabled: order_by
  user: user_order_by
}

# select columns of table "user_settings"
enum user_settings_select_column {
  # column name
  lastKnownMatch

  # column name
  matchAuthCode

  # column name
  notificationCommunityEnabled

  # column name
  notificationDiscordEnabled

  # column name
  notificationEconomyEnabled

  # column name
  notificationFaceitEnabled

  # column name
  notificationGameEnabled

  # column name
  notificationVACEnabled
}

# columns and relationships of "utility_activated"
type utility_activated {
  createdAt: timestamp!
  entityId: Int!
  id: Int!

  # An object relationship
  position: position
  positionId: Int

  # An object relationship
  round: round
  roundId: Int
  tick: Int!
  type: utility_activated_type_enum!
}

# aggregated selection of "utility_activated"
type utility_activated_aggregate {
  aggregate: utility_activated_aggregate_fields
  nodes: [utility_activated!]!
}

# aggregate fields of "utility_activated"
type utility_activated_aggregate_fields {
  avg: utility_activated_avg_fields
  count(columns: [utility_activated_select_column!], distinct: Boolean): Int
  max: utility_activated_max_fields
  min: utility_activated_min_fields
  stddev: utility_activated_stddev_fields
  stddev_pop: utility_activated_stddev_pop_fields
  stddev_samp: utility_activated_stddev_samp_fields
  sum: utility_activated_sum_fields
  var_pop: utility_activated_var_pop_fields
  var_samp: utility_activated_var_samp_fields
  variance: utility_activated_variance_fields
}

# order by aggregate values of table "utility_activated"
input utility_activated_aggregate_order_by {
  avg: utility_activated_avg_order_by
  count: order_by
  max: utility_activated_max_order_by
  min: utility_activated_min_order_by
  stddev: utility_activated_stddev_order_by
  stddev_pop: utility_activated_stddev_pop_order_by
  stddev_samp: utility_activated_stddev_samp_order_by
  sum: utility_activated_sum_order_by
  var_pop: utility_activated_var_pop_order_by
  var_samp: utility_activated_var_samp_order_by
  variance: utility_activated_variance_order_by
}

# aggregate avg on columns
type utility_activated_avg_fields {
  entityId: Float
  id: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by avg() on columns of table "utility_activated"
input utility_activated_avg_order_by {
  entityId: order_by
  id: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# Boolean expression to filter rows from the table "utility_activated". All fields are combined with a logical 'AND'.
input utility_activated_bool_exp {
  _and: [utility_activated_bool_exp]
  _not: utility_activated_bool_exp
  _or: [utility_activated_bool_exp]
  createdAt: timestamp_comparison_exp
  entityId: Int_comparison_exp
  id: Int_comparison_exp
  position: position_bool_exp
  positionId: Int_comparison_exp
  round: round_bool_exp
  roundId: Int_comparison_exp
  tick: Int_comparison_exp
  type: utility_activated_type_enum_comparison_exp
}

# aggregate max on columns
type utility_activated_max_fields {
  entityId: Int
  id: Int
  positionId: Int
  roundId: Int
  tick: Int
}

# order by max() on columns of table "utility_activated"
input utility_activated_max_order_by {
  entityId: order_by
  id: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate min on columns
type utility_activated_min_fields {
  entityId: Int
  id: Int
  positionId: Int
  roundId: Int
  tick: Int
}

# order by min() on columns of table "utility_activated"
input utility_activated_min_order_by {
  entityId: order_by
  id: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# ordering options when selecting data from "utility_activated"
input utility_activated_order_by {
  createdAt: order_by
  entityId: order_by
  id: order_by
  position: position_order_by
  positionId: order_by
  round: round_order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# select columns of table "utility_activated"
enum utility_activated_select_column {
  # column name
  createdAt

  # column name
  entityId

  # column name
  id

  # column name
  positionId

  # column name
  roundId

  # column name
  tick

  # column name
  type
}

# aggregate stddev on columns
type utility_activated_stddev_fields {
  entityId: Float
  id: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by stddev() on columns of table "utility_activated"
input utility_activated_stddev_order_by {
  entityId: order_by
  id: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate stddev_pop on columns
type utility_activated_stddev_pop_fields {
  entityId: Float
  id: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by stddev_pop() on columns of table "utility_activated"
input utility_activated_stddev_pop_order_by {
  entityId: order_by
  id: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate stddev_samp on columns
type utility_activated_stddev_samp_fields {
  entityId: Float
  id: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by stddev_samp() on columns of table "utility_activated"
input utility_activated_stddev_samp_order_by {
  entityId: order_by
  id: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate sum on columns
type utility_activated_sum_fields {
  entityId: Int
  id: Int
  positionId: Int
  roundId: Int
  tick: Int
}

# order by sum() on columns of table "utility_activated"
input utility_activated_sum_order_by {
  entityId: order_by
  id: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

scalar utility_activated_type_enum

# expression to compare columns of type utility_activated_type_enum. All fields are combined with logical 'AND'.
input utility_activated_type_enum_comparison_exp {
  _eq: utility_activated_type_enum
  _gt: utility_activated_type_enum
  _gte: utility_activated_type_enum
  _in: [utility_activated_type_enum!]
  _is_null: Boolean
  _lt: utility_activated_type_enum
  _lte: utility_activated_type_enum
  _neq: utility_activated_type_enum
  _nin: [utility_activated_type_enum!]
}

# aggregate var_pop on columns
type utility_activated_var_pop_fields {
  entityId: Float
  id: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by var_pop() on columns of table "utility_activated"
input utility_activated_var_pop_order_by {
  entityId: order_by
  id: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate var_samp on columns
type utility_activated_var_samp_fields {
  entityId: Float
  id: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by var_samp() on columns of table "utility_activated"
input utility_activated_var_samp_order_by {
  entityId: order_by
  id: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate variance on columns
type utility_activated_variance_fields {
  entityId: Float
  id: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by variance() on columns of table "utility_activated"
input utility_activated_variance_order_by {
  entityId: order_by
  id: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# columns and relationships of "utility_thrown"
type utility_thrown {
  createdAt: timestamp!
  entityId: Int!
  id: Int!

  # An object relationship
  player: player_info
  playerId: Int

  # An object relationship
  position: position
  positionId: Int

  # An object relationship
  round: round
  roundId: Int
  tick: Int!
  type: utility_thrown_type_enum!
}

# aggregated selection of "utility_thrown"
type utility_thrown_aggregate {
  aggregate: utility_thrown_aggregate_fields
  nodes: [utility_thrown!]!
}

# aggregate fields of "utility_thrown"
type utility_thrown_aggregate_fields {
  avg: utility_thrown_avg_fields
  count(columns: [utility_thrown_select_column!], distinct: Boolean): Int
  max: utility_thrown_max_fields
  min: utility_thrown_min_fields
  stddev: utility_thrown_stddev_fields
  stddev_pop: utility_thrown_stddev_pop_fields
  stddev_samp: utility_thrown_stddev_samp_fields
  sum: utility_thrown_sum_fields
  var_pop: utility_thrown_var_pop_fields
  var_samp: utility_thrown_var_samp_fields
  variance: utility_thrown_variance_fields
}

# order by aggregate values of table "utility_thrown"
input utility_thrown_aggregate_order_by {
  avg: utility_thrown_avg_order_by
  count: order_by
  max: utility_thrown_max_order_by
  min: utility_thrown_min_order_by
  stddev: utility_thrown_stddev_order_by
  stddev_pop: utility_thrown_stddev_pop_order_by
  stddev_samp: utility_thrown_stddev_samp_order_by
  sum: utility_thrown_sum_order_by
  var_pop: utility_thrown_var_pop_order_by
  var_samp: utility_thrown_var_samp_order_by
  variance: utility_thrown_variance_order_by
}

# aggregate avg on columns
type utility_thrown_avg_fields {
  entityId: Float
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by avg() on columns of table "utility_thrown"
input utility_thrown_avg_order_by {
  entityId: order_by
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# Boolean expression to filter rows from the table "utility_thrown". All fields are combined with a logical 'AND'.
input utility_thrown_bool_exp {
  _and: [utility_thrown_bool_exp]
  _not: utility_thrown_bool_exp
  _or: [utility_thrown_bool_exp]
  createdAt: timestamp_comparison_exp
  entityId: Int_comparison_exp
  id: Int_comparison_exp
  player: player_info_bool_exp
  playerId: Int_comparison_exp
  position: position_bool_exp
  positionId: Int_comparison_exp
  round: round_bool_exp
  roundId: Int_comparison_exp
  tick: Int_comparison_exp
  type: utility_thrown_type_enum_comparison_exp
}

# aggregate max on columns
type utility_thrown_max_fields {
  entityId: Int
  id: Int
  playerId: Int
  positionId: Int
  roundId: Int
  tick: Int
}

# order by max() on columns of table "utility_thrown"
input utility_thrown_max_order_by {
  entityId: order_by
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate min on columns
type utility_thrown_min_fields {
  entityId: Int
  id: Int
  playerId: Int
  positionId: Int
  roundId: Int
  tick: Int
}

# order by min() on columns of table "utility_thrown"
input utility_thrown_min_order_by {
  entityId: order_by
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# ordering options when selecting data from "utility_thrown"
input utility_thrown_order_by {
  createdAt: order_by
  entityId: order_by
  id: order_by
  player: player_info_order_by
  playerId: order_by
  position: position_order_by
  positionId: order_by
  round: round_order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# select columns of table "utility_thrown"
enum utility_thrown_select_column {
  # column name
  createdAt

  # column name
  entityId

  # column name
  id

  # column name
  playerId

  # column name
  positionId

  # column name
  roundId

  # column name
  tick

  # column name
  type
}

# aggregate stddev on columns
type utility_thrown_stddev_fields {
  entityId: Float
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by stddev() on columns of table "utility_thrown"
input utility_thrown_stddev_order_by {
  entityId: order_by
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate stddev_pop on columns
type utility_thrown_stddev_pop_fields {
  entityId: Float
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by stddev_pop() on columns of table "utility_thrown"
input utility_thrown_stddev_pop_order_by {
  entityId: order_by
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate stddev_samp on columns
type utility_thrown_stddev_samp_fields {
  entityId: Float
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by stddev_samp() on columns of table "utility_thrown"
input utility_thrown_stddev_samp_order_by {
  entityId: order_by
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate sum on columns
type utility_thrown_sum_fields {
  entityId: Int
  id: Int
  playerId: Int
  positionId: Int
  roundId: Int
  tick: Int
}

# order by sum() on columns of table "utility_thrown"
input utility_thrown_sum_order_by {
  entityId: order_by
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

scalar utility_thrown_type_enum

# expression to compare columns of type utility_thrown_type_enum. All fields are combined with logical 'AND'.
input utility_thrown_type_enum_comparison_exp {
  _eq: utility_thrown_type_enum
  _gt: utility_thrown_type_enum
  _gte: utility_thrown_type_enum
  _in: [utility_thrown_type_enum!]
  _is_null: Boolean
  _lt: utility_thrown_type_enum
  _lte: utility_thrown_type_enum
  _neq: utility_thrown_type_enum
  _nin: [utility_thrown_type_enum!]
}

# aggregate var_pop on columns
type utility_thrown_var_pop_fields {
  entityId: Float
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by var_pop() on columns of table "utility_thrown"
input utility_thrown_var_pop_order_by {
  entityId: order_by
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate var_samp on columns
type utility_thrown_var_samp_fields {
  entityId: Float
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by var_samp() on columns of table "utility_thrown"
input utility_thrown_var_samp_order_by {
  entityId: order_by
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# aggregate variance on columns
type utility_thrown_variance_fields {
  entityId: Float
  id: Float
  playerId: Float
  positionId: Float
  roundId: Float
  tick: Float
}

# order by variance() on columns of table "utility_thrown"
input utility_thrown_variance_order_by {
  entityId: order_by
  id: order_by
  playerId: order_by
  positionId: order_by
  roundId: order_by
  tick: order_by
}

# columns and relationships of "weapon_status"
type weapon_status {
  createdAt: timestamp!
  id: Int!

  # An object relationship
  player: player_info
  playerId: Int

  # An object relationship
  round: round
  roundId: Int
  tick: Int!
  type: Int!
  weapon: weapon_status_weapon_enum!
}

# aggregated selection of "weapon_status"
type weapon_status_aggregate {
  aggregate: weapon_status_aggregate_fields
  nodes: [weapon_status!]!
}

# aggregate fields of "weapon_status"
type weapon_status_aggregate_fields {
  avg: weapon_status_avg_fields
  count(columns: [weapon_status_select_column!], distinct: Boolean): Int
  max: weapon_status_max_fields
  min: weapon_status_min_fields
  stddev: weapon_status_stddev_fields
  stddev_pop: weapon_status_stddev_pop_fields
  stddev_samp: weapon_status_stddev_samp_fields
  sum: weapon_status_sum_fields
  var_pop: weapon_status_var_pop_fields
  var_samp: weapon_status_var_samp_fields
  variance: weapon_status_variance_fields
}

# order by aggregate values of table "weapon_status"
input weapon_status_aggregate_order_by {
  avg: weapon_status_avg_order_by
  count: order_by
  max: weapon_status_max_order_by
  min: weapon_status_min_order_by
  stddev: weapon_status_stddev_order_by
  stddev_pop: weapon_status_stddev_pop_order_by
  stddev_samp: weapon_status_stddev_samp_order_by
  sum: weapon_status_sum_order_by
  var_pop: weapon_status_var_pop_order_by
  var_samp: weapon_status_var_samp_order_by
  variance: weapon_status_variance_order_by
}

# aggregate avg on columns
type weapon_status_avg_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
  type: Float
}

# order by avg() on columns of table "weapon_status"
input weapon_status_avg_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# Boolean expression to filter rows from the table "weapon_status". All fields are combined with a logical 'AND'.
input weapon_status_bool_exp {
  _and: [weapon_status_bool_exp]
  _not: weapon_status_bool_exp
  _or: [weapon_status_bool_exp]
  createdAt: timestamp_comparison_exp
  id: Int_comparison_exp
  player: player_info_bool_exp
  playerId: Int_comparison_exp
  round: round_bool_exp
  roundId: Int_comparison_exp
  tick: Int_comparison_exp
  type: Int_comparison_exp
  weapon: weapon_status_weapon_enum_comparison_exp
}

# aggregate max on columns
type weapon_status_max_fields {
  id: Int
  playerId: Int
  roundId: Int
  tick: Int
  type: Int
}

# order by max() on columns of table "weapon_status"
input weapon_status_max_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# aggregate min on columns
type weapon_status_min_fields {
  id: Int
  playerId: Int
  roundId: Int
  tick: Int
  type: Int
}

# order by min() on columns of table "weapon_status"
input weapon_status_min_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# ordering options when selecting data from "weapon_status"
input weapon_status_order_by {
  createdAt: order_by
  id: order_by
  player: player_info_order_by
  playerId: order_by
  round: round_order_by
  roundId: order_by
  tick: order_by
  type: order_by
  weapon: order_by
}

# select columns of table "weapon_status"
enum weapon_status_select_column {
  # column name
  createdAt

  # column name
  id

  # column name
  playerId

  # column name
  roundId

  # column name
  tick

  # column name
  type

  # column name
  weapon
}

# aggregate stddev on columns
type weapon_status_stddev_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
  type: Float
}

# order by stddev() on columns of table "weapon_status"
input weapon_status_stddev_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# aggregate stddev_pop on columns
type weapon_status_stddev_pop_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
  type: Float
}

# order by stddev_pop() on columns of table "weapon_status"
input weapon_status_stddev_pop_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# aggregate stddev_samp on columns
type weapon_status_stddev_samp_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
  type: Float
}

# order by stddev_samp() on columns of table "weapon_status"
input weapon_status_stddev_samp_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# aggregate sum on columns
type weapon_status_sum_fields {
  id: Int
  playerId: Int
  roundId: Int
  tick: Int
  type: Int
}

# order by sum() on columns of table "weapon_status"
input weapon_status_sum_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# aggregate var_pop on columns
type weapon_status_var_pop_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
  type: Float
}

# order by var_pop() on columns of table "weapon_status"
input weapon_status_var_pop_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# aggregate var_samp on columns
type weapon_status_var_samp_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
  type: Float
}

# order by var_samp() on columns of table "weapon_status"
input weapon_status_var_samp_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

# aggregate variance on columns
type weapon_status_variance_fields {
  id: Float
  playerId: Float
  roundId: Float
  tick: Float
  type: Float
}

# order by variance() on columns of table "weapon_status"
input weapon_status_variance_order_by {
  id: order_by
  playerId: order_by
  roundId: order_by
  tick: order_by
  type: order_by
}

scalar weapon_status_weapon_enum

# expression to compare columns of type weapon_status_weapon_enum. All fields are combined with logical 'AND'.
input weapon_status_weapon_enum_comparison_exp {
  _eq: weapon_status_weapon_enum
  _gt: weapon_status_weapon_enum
  _gte: weapon_status_weapon_enum
  _in: [weapon_status_weapon_enum!]
  _is_null: Boolean
  _lt: weapon_status_weapon_enum
  _lte: weapon_status_weapon_enum
  _neq: weapon_status_weapon_enum
  _nin: [weapon_status_weapon_enum!]
}

